// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: match.proto

/*
	Package proto is a generated protocol buffer package.

	It is generated from these files:
		match.proto

	It has these top-level messages:
		ListsRequest
		ListsResponse
		Id
		MatchIcon
		List
		Fee
		SubFee
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import bytes "bytes"

import strings "strings"
import reflect "reflect"
import sortkeys "github.com/gogo/protobuf/sortkeys"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

// matchservice.lists 请求参数
type ListsRequest struct {
	Cmd              uint64 `protobuf:"varint,1,opt,name=cmd" json:"cmd"`
	App              uint64 `protobuf:"varint,2,opt,name=app" json:"app"`
	GameId           uint64 `protobuf:"varint,3,opt,name=game_id,json=gameId" json:"game_id"`
	Mid              uint64 `protobuf:"varint,4,opt,name=mid" json:"mid"`
	Ssid             string `protobuf:"bytes,5,opt,name=ssid" json:"ssid"`
	Action           string `protobuf:"bytes,6,opt,name=action" json:"action"`
	Page             uint32 `protobuf:"varint,7,opt,name=page" json:"page"`
	Timestamp        uint64 `protobuf:"varint,8,opt,name=timestamp" json:"timestamp"`
	Seq              uint32 `protobuf:"varint,9,opt,name=seq" json:"seq"`
	Ids              []List `protobuf:"bytes,10,rep,name=ids" json:"ids"`
	HallVersion      uint32 `protobuf:"varint,11,opt,name=hall_version,json=hallVersion" json:"hall_version"`
	AreaId           uint32 `protobuf:"varint,12,opt,name=area_id,json=areaId" json:"area_id"`
	IsNew            uint32 `protobuf:"varint,13,opt,name=isNew" json:"isNew"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ListsRequest) Reset()                    { *m = ListsRequest{} }
func (*ListsRequest) ProtoMessage()               {}
func (*ListsRequest) Descriptor() ([]byte, []int) { return fileDescriptorMatch, []int{0} }

func (m *ListsRequest) GetCmd() uint64 {
	if m != nil {
		return m.Cmd
	}
	return 0
}

func (m *ListsRequest) GetApp() uint64 {
	if m != nil {
		return m.App
	}
	return 0
}

func (m *ListsRequest) GetGameId() uint64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

func (m *ListsRequest) GetMid() uint64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *ListsRequest) GetSsid() string {
	if m != nil {
		return m.Ssid
	}
	return ""
}

func (m *ListsRequest) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *ListsRequest) GetPage() uint32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *ListsRequest) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ListsRequest) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *ListsRequest) GetIds() []List {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *ListsRequest) GetHallVersion() uint32 {
	if m != nil {
		return m.HallVersion
	}
	return 0
}

func (m *ListsRequest) GetAreaId() uint32 {
	if m != nil {
		return m.AreaId
	}
	return 0
}

func (m *ListsRequest) GetIsNew() uint32 {
	if m != nil {
		return m.IsNew
	}
	return 0
}

// matchservice.lists 返回参数
type ListsResponse struct {
	Tpage            uint64               `protobuf:"varint,1,opt,name=tpage" json:"tpage"`
	Srvtime          uint64               `protobuf:"varint,2,opt,name=srvtime" json:"srvtime"`
	List             map[uint32]List      `protobuf:"bytes,3,rep,name=list" json:"list" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Filter           uint32               `protobuf:"varint,4,opt,name=filter" json:"filter"`
	Iconmax          uint32               `protobuf:"varint,5,opt,name=iconmax" json:"iconmax"`
	Pnum             uint32               `protobuf:"varint,6,opt,name=pnum" json:"pnum"`
	Apply            []uint64             `protobuf:"varint,7,rep,name=apply" json:"apply,omitempty"`
	Delete           map[uint32]List      `protobuf:"bytes,8,rep,name=delete" json:"delete" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Update           map[uint32]List      `protobuf:"bytes,9,rep,name=update" json:"update" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	MatchIcons       map[string]MatchIcon `protobuf:"bytes,10,rep,name=match_icons,json=matchIcons" json:"match_icons" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Sort             map[string]uint32    `protobuf:"bytes,11,rep,name=sort" json:"sort" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *ListsResponse) Reset()                    { *m = ListsResponse{} }
func (*ListsResponse) ProtoMessage()               {}
func (*ListsResponse) Descriptor() ([]byte, []int) { return fileDescriptorMatch, []int{1} }

func (m *ListsResponse) GetTpage() uint64 {
	if m != nil {
		return m.Tpage
	}
	return 0
}

func (m *ListsResponse) GetSrvtime() uint64 {
	if m != nil {
		return m.Srvtime
	}
	return 0
}

func (m *ListsResponse) GetList() map[uint32]List {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *ListsResponse) GetFilter() uint32 {
	if m != nil {
		return m.Filter
	}
	return 0
}

func (m *ListsResponse) GetIconmax() uint32 {
	if m != nil {
		return m.Iconmax
	}
	return 0
}

func (m *ListsResponse) GetPnum() uint32 {
	if m != nil {
		return m.Pnum
	}
	return 0
}

func (m *ListsResponse) GetApply() []uint64 {
	if m != nil {
		return m.Apply
	}
	return nil
}

func (m *ListsResponse) GetDelete() map[uint32]List {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *ListsResponse) GetUpdate() map[uint32]List {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *ListsResponse) GetMatchIcons() map[string]MatchIcon {
	if m != nil {
		return m.MatchIcons
	}
	return nil
}

func (m *ListsResponse) GetSort() map[string]uint32 {
	if m != nil {
		return m.Sort
	}
	return nil
}

type Id struct {
	Type              uint32 `protobuf:"varint,1,opt,name=type" json:"type"`
	Id                uint64 `protobuf:"varint,2,opt,name=id" json:"id"`
	Configid          uint64 `protobuf:"varint,3,opt,name=configid" json:"configid"`
	Applynum          uint64 `protobuf:"varint,4,opt,name=Applynum" json:"Applynum"`
	Allapplynum       uint64 `protobuf:"varint,5,opt,name=Allapplynum" json:"Allapplynum"`
	Stime             uint64 `protobuf:"varint,6,opt,name=Stime" json:"Stime"`
	Etime             uint64 `protobuf:"varint,7,opt,name=Etime" json:"Etime"`
	Status            uint32 `protobuf:"varint,8,opt,name=Status" json:"Status"`
	Matchpartitions   uint64 `protobuf:"varint,9,opt,name=Matchpartitions" json:"Matchpartitions"`
	FreeTimes         uint32 `protobuf:"varint,10,opt,name=FreeTimes" json:"FreeTimes"`
	AllFreeTimes      uint32 `protobuf:"varint,11,opt,name=AllFreeTimes" json:"AllFreeTimes"`
	AllDiscountNum    uint32 `protobuf:"varint,12,opt,name=AllDiscountNum" json:"AllDiscountNum"`
	RemainDiscountNum uint32 `protobuf:"varint,13,opt,name=RemainDiscountNum" json:"RemainDiscountNum"`
	Fee               []Fee  `protobuf:"bytes,14,rep,name=fee" json:"fee"`
	XXX_unrecognized  []byte `json:"-"`
}

func (m *Id) Reset()                    { *m = Id{} }
func (*Id) ProtoMessage()               {}
func (*Id) Descriptor() ([]byte, []int) { return fileDescriptorMatch, []int{2} }

func (m *Id) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Id) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Id) GetConfigid() uint64 {
	if m != nil {
		return m.Configid
	}
	return 0
}

func (m *Id) GetApplynum() uint64 {
	if m != nil {
		return m.Applynum
	}
	return 0
}

func (m *Id) GetAllapplynum() uint64 {
	if m != nil {
		return m.Allapplynum
	}
	return 0
}

func (m *Id) GetStime() uint64 {
	if m != nil {
		return m.Stime
	}
	return 0
}

func (m *Id) GetEtime() uint64 {
	if m != nil {
		return m.Etime
	}
	return 0
}

func (m *Id) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Id) GetMatchpartitions() uint64 {
	if m != nil {
		return m.Matchpartitions
	}
	return 0
}

func (m *Id) GetFreeTimes() uint32 {
	if m != nil {
		return m.FreeTimes
	}
	return 0
}

func (m *Id) GetAllFreeTimes() uint32 {
	if m != nil {
		return m.AllFreeTimes
	}
	return 0
}

func (m *Id) GetAllDiscountNum() uint32 {
	if m != nil {
		return m.AllDiscountNum
	}
	return 0
}

func (m *Id) GetRemainDiscountNum() uint32 {
	if m != nil {
		return m.RemainDiscountNum
	}
	return 0
}

func (m *Id) GetFee() []Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

type MatchIcon struct {
	Icon             string `protobuf:"bytes,1,opt,name=icon" json:"icon"`
	Color            string `protobuf:"bytes,2,opt,name=color" json:"color"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *MatchIcon) Reset()                    { *m = MatchIcon{} }
func (*MatchIcon) ProtoMessage()               {}
func (*MatchIcon) Descriptor() ([]byte, []int) { return fileDescriptorMatch, []int{3} }

func (m *MatchIcon) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *MatchIcon) GetColor() string {
	if m != nil {
		return m.Color
	}
	return ""
}

type List struct {
	Id                  uint64            `protobuf:"varint,1,opt,name=id" json:"id"`
	Type                uint32            `protobuf:"varint,2,opt,name=type" json:"type"`
	Mname               string            `protobuf:"bytes,3,opt,name=mname" json:"mname"`
	Micon               string            `protobuf:"bytes,4,opt,name=micon" json:"micon"`
	Iconweight          string            `protobuf:"bytes,5,opt,name=iconweight" json:"iconweight"`
	AdIcon              string            `protobuf:"bytes,6,opt,name=adIcon" json:"adIcon"`
	ListSort            string            `protobuf:"bytes,7,opt,name=listSort" json:"listSort"`
	Stime               uint64            `protobuf:"varint,8,opt,name=stime" json:"stime"`
	Etime               uint64            `protobuf:"varint,9,opt,name=etime" json:"etime"`
	Gameid              uint64            `protobuf:"varint,10,opt,name=gameid" json:"gameid"`
	Gamesort            uint64            `protobuf:"varint,11,opt,name=gamesort" json:"gamesort"`
	Requestnum          string            `protobuf:"bytes,12,opt,name=requestnum" json:"requestnum"`
	Applynum            uint64            `protobuf:"varint,13,opt,name=applynum" json:"applynum"`
	Allowwaittime       uint32            `protobuf:"varint,14,opt,name=allowwaittime" json:"allowwaittime"`
	Champion            string            `protobuf:"bytes,15,opt,name=champion" json:"champion"`
	Fee                 []Fee             `protobuf:"bytes,16,rep,name=fee" json:"fee"`
	Status              uint32            `protobuf:"varint,17,opt,name=status" json:"status"`
	Looptype            uint32            `protobuf:"varint,18,opt,name=looptype" json:"looptype"`
	Loopinterval        float32           `protobuf:"fixed32,19,opt,name=loopinterval" json:"loopinterval"`
	Loopendtime         string            `protobuf:"bytes,20,opt,name=loopendtime" json:"loopendtime"`
	RewardUrl           string            `protobuf:"bytes,21,opt,name=rewardUrl" json:"rewardUrl"`
	RewardDescribe      string            `protobuf:"bytes,22,opt,name=rewardDescribe" json:"rewardDescribe"`
	ThresholdType       float64           `protobuf:"fixed64,23,opt,name=thresholdType" json:"thresholdType"`
	Threshold           float64           `protobuf:"fixed64,24,opt,name=threshold" json:"threshold"`
	Configid            string            `protobuf:"bytes,25,opt,name=configid" json:"configid"`
	Matchtags           string            `protobuf:"bytes,26,opt,name=matchtags" json:"matchtags"`
	Matchentrycode      string            `protobuf:"bytes,27,opt,name=matchentrycode" json:"matchentrycode"`
	Matchentryinfo      string            `protobuf:"bytes,28,opt,name=matchentryinfo" json:"matchentryinfo"`
	Sname               string            `protobuf:"bytes,29,opt,name=sname" json:"sname"`
	Gamename            string            `protobuf:"bytes,30,opt,name=gamename" json:"gamename"`
	Advicon             string            `protobuf:"bytes,31,opt,name=advicon" json:"advicon"`
	Maxawardpool        uint32            `protobuf:"varint,32,opt,name=maxawardpool" json:"maxawardpool"`
	Mclabel             map[string]string `protobuf:"bytes,33,rep,name=mclabel" json:"mclabel" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Allapplynum         uint64            `protobuf:"varint,34,opt,name=allapplynum" json:"allapplynum"`
	AllFreeTimes        uint32            `protobuf:"varint,35,opt,name=allFreeTimes" json:"allFreeTimes"`
	FreeTimes           uint32            `protobuf:"varint,36,opt,name=freeTimes" json:"freeTimes"`
	Moneylimit          map[string]string `protobuf:"bytes,37,rep,name=moneylimit" json:"moneylimit" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Recommendmatchcfgid uint64            `protobuf:"varint,38,opt,name=recommendmatchcfgid" json:"recommendmatchcfgid"`
	Endtime             uint64            `protobuf:"varint,39,opt,name=endtime" json:"endtime"`
	Matchpartitions     uint64            `protobuf:"varint,40,opt,name=matchpartitions" json:"matchpartitions"`
	Isfhmatch           float64           `protobuf:"fixed64,41,opt,name=isfhmatch" json:"isfhmatch"`
	Loopintervaltime    uint64            `protobuf:"varint,42,opt,name=loopintervaltime" json:"loopintervaltime"`
	Firstbegintime      uint64            `protobuf:"varint,43,opt,name=firstbegintime" json:"firstbegintime"`
	DiscountPrice       uint64            `protobuf:"varint,44,opt,name=discountPrice" json:"discountPrice"`
	DiscountType        uint32            `protobuf:"varint,45,opt,name=discountType" json:"discountType"`
	AllDiscountNum      uint32            `protobuf:"varint,46,opt,name=allDiscountNum" json:"allDiscountNum"`
	RemainDiscountNum   uint32            `protobuf:"varint,47,opt,name=remainDiscountNum" json:"remainDiscountNum"`
	XXX_unrecognized    []byte            `json:"-"`
}

func (m *List) Reset()                    { *m = List{} }
func (*List) ProtoMessage()               {}
func (*List) Descriptor() ([]byte, []int) { return fileDescriptorMatch, []int{4} }

func (m *List) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *List) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *List) GetMname() string {
	if m != nil {
		return m.Mname
	}
	return ""
}

func (m *List) GetMicon() string {
	if m != nil {
		return m.Micon
	}
	return ""
}

func (m *List) GetIconweight() string {
	if m != nil {
		return m.Iconweight
	}
	return ""
}

func (m *List) GetAdIcon() string {
	if m != nil {
		return m.AdIcon
	}
	return ""
}

func (m *List) GetListSort() string {
	if m != nil {
		return m.ListSort
	}
	return ""
}

func (m *List) GetStime() uint64 {
	if m != nil {
		return m.Stime
	}
	return 0
}

func (m *List) GetEtime() uint64 {
	if m != nil {
		return m.Etime
	}
	return 0
}

func (m *List) GetGameid() uint64 {
	if m != nil {
		return m.Gameid
	}
	return 0
}

func (m *List) GetGamesort() uint64 {
	if m != nil {
		return m.Gamesort
	}
	return 0
}

func (m *List) GetRequestnum() string {
	if m != nil {
		return m.Requestnum
	}
	return ""
}

func (m *List) GetApplynum() uint64 {
	if m != nil {
		return m.Applynum
	}
	return 0
}

func (m *List) GetAllowwaittime() uint32 {
	if m != nil {
		return m.Allowwaittime
	}
	return 0
}

func (m *List) GetChampion() string {
	if m != nil {
		return m.Champion
	}
	return ""
}

func (m *List) GetFee() []Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *List) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *List) GetLooptype() uint32 {
	if m != nil {
		return m.Looptype
	}
	return 0
}

func (m *List) GetLoopinterval() float32 {
	if m != nil {
		return m.Loopinterval
	}
	return 0
}

func (m *List) GetLoopendtime() string {
	if m != nil {
		return m.Loopendtime
	}
	return ""
}

func (m *List) GetRewardUrl() string {
	if m != nil {
		return m.RewardUrl
	}
	return ""
}

func (m *List) GetRewardDescribe() string {
	if m != nil {
		return m.RewardDescribe
	}
	return ""
}

func (m *List) GetThresholdType() float64 {
	if m != nil {
		return m.ThresholdType
	}
	return 0
}

func (m *List) GetThreshold() float64 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *List) GetConfigid() string {
	if m != nil {
		return m.Configid
	}
	return ""
}

func (m *List) GetMatchtags() string {
	if m != nil {
		return m.Matchtags
	}
	return ""
}

func (m *List) GetMatchentrycode() string {
	if m != nil {
		return m.Matchentrycode
	}
	return ""
}

func (m *List) GetMatchentryinfo() string {
	if m != nil {
		return m.Matchentryinfo
	}
	return ""
}

func (m *List) GetSname() string {
	if m != nil {
		return m.Sname
	}
	return ""
}

func (m *List) GetGamename() string {
	if m != nil {
		return m.Gamename
	}
	return ""
}

func (m *List) GetAdvicon() string {
	if m != nil {
		return m.Advicon
	}
	return ""
}

func (m *List) GetMaxawardpool() uint32 {
	if m != nil {
		return m.Maxawardpool
	}
	return 0
}

func (m *List) GetMclabel() map[string]string {
	if m != nil {
		return m.Mclabel
	}
	return nil
}

func (m *List) GetAllapplynum() uint64 {
	if m != nil {
		return m.Allapplynum
	}
	return 0
}

func (m *List) GetAllFreeTimes() uint32 {
	if m != nil {
		return m.AllFreeTimes
	}
	return 0
}

func (m *List) GetFreeTimes() uint32 {
	if m != nil {
		return m.FreeTimes
	}
	return 0
}

func (m *List) GetMoneylimit() map[string]string {
	if m != nil {
		return m.Moneylimit
	}
	return nil
}

func (m *List) GetRecommendmatchcfgid() uint64 {
	if m != nil {
		return m.Recommendmatchcfgid
	}
	return 0
}

func (m *List) GetEndtime() uint64 {
	if m != nil {
		return m.Endtime
	}
	return 0
}

func (m *List) GetMatchpartitions() uint64 {
	if m != nil {
		return m.Matchpartitions
	}
	return 0
}

func (m *List) GetIsfhmatch() float64 {
	if m != nil {
		return m.Isfhmatch
	}
	return 0
}

func (m *List) GetLoopintervaltime() uint64 {
	if m != nil {
		return m.Loopintervaltime
	}
	return 0
}

func (m *List) GetFirstbegintime() uint64 {
	if m != nil {
		return m.Firstbegintime
	}
	return 0
}

func (m *List) GetDiscountPrice() uint64 {
	if m != nil {
		return m.DiscountPrice
	}
	return 0
}

func (m *List) GetDiscountType() uint32 {
	if m != nil {
		return m.DiscountType
	}
	return 0
}

func (m *List) GetAllDiscountNum() uint32 {
	if m != nil {
		return m.AllDiscountNum
	}
	return 0
}

func (m *List) GetRemainDiscountNum() uint32 {
	if m != nil {
		return m.RemainDiscountNum
	}
	return 0
}

// 道具类型 道具数量 道具描述 优惠标签（1为开启）（特殊处理化金币和钻石。0为金币、2为钻石）
type Fee struct {
	Subfee           []SubFee `protobuf:"bytes,1,rep,name=subfee" json:"subfee"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Fee) Reset()                    { *m = Fee{} }
func (*Fee) ProtoMessage()               {}
func (*Fee) Descriptor() ([]byte, []int) { return fileDescriptorMatch, []int{5} }

func (m *Fee) GetSubfee() []SubFee {
	if m != nil {
		return m.Subfee
	}
	return nil
}

type SubFee struct {
	Type             uint32 `protobuf:"varint,1,opt,name=type" json:"type"`
	Num              uint64 `protobuf:"varint,2,opt,name=num" json:"num"`
	Desc             string `protobuf:"bytes,3,opt,name=desc" json:"desc"`
	Label            uint32 `protobuf:"varint,4,opt,name=label" json:"label"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SubFee) Reset()                    { *m = SubFee{} }
func (*SubFee) ProtoMessage()               {}
func (*SubFee) Descriptor() ([]byte, []int) { return fileDescriptorMatch, []int{6} }

func (m *SubFee) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *SubFee) GetNum() uint64 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *SubFee) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *SubFee) GetLabel() uint32 {
	if m != nil {
		return m.Label
	}
	return 0
}

func init() {
	proto1.RegisterType((*ListsRequest)(nil), "proto.ListsRequest")
	proto1.RegisterType((*ListsResponse)(nil), "proto.ListsResponse")
	proto1.RegisterType((*Id)(nil), "proto.Id")
	proto1.RegisterType((*MatchIcon)(nil), "proto.MatchIcon")
	proto1.RegisterType((*List)(nil), "proto.List")
	proto1.RegisterType((*Fee)(nil), "proto.Fee")
	proto1.RegisterType((*SubFee)(nil), "proto.SubFee")
}
func (this *ListsRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ListsRequest)
	if !ok {
		that2, ok := that.(ListsRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ListsRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ListsRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ListsRequest but is not nil && this == nil")
	}
	if this.Cmd != that1.Cmd {
		return fmt.Errorf("Cmd this(%v) Not Equal that(%v)", this.Cmd, that1.Cmd)
	}
	if this.App != that1.App {
		return fmt.Errorf("App this(%v) Not Equal that(%v)", this.App, that1.App)
	}
	if this.GameId != that1.GameId {
		return fmt.Errorf("GameId this(%v) Not Equal that(%v)", this.GameId, that1.GameId)
	}
	if this.Mid != that1.Mid {
		return fmt.Errorf("Mid this(%v) Not Equal that(%v)", this.Mid, that1.Mid)
	}
	if this.Ssid != that1.Ssid {
		return fmt.Errorf("Ssid this(%v) Not Equal that(%v)", this.Ssid, that1.Ssid)
	}
	if this.Action != that1.Action {
		return fmt.Errorf("Action this(%v) Not Equal that(%v)", this.Action, that1.Action)
	}
	if this.Page != that1.Page {
		return fmt.Errorf("Page this(%v) Not Equal that(%v)", this.Page, that1.Page)
	}
	if this.Timestamp != that1.Timestamp {
		return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", this.Timestamp, that1.Timestamp)
	}
	if this.Seq != that1.Seq {
		return fmt.Errorf("Seq this(%v) Not Equal that(%v)", this.Seq, that1.Seq)
	}
	if len(this.Ids) != len(that1.Ids) {
		return fmt.Errorf("Ids this(%v) Not Equal that(%v)", len(this.Ids), len(that1.Ids))
	}
	for i := range this.Ids {
		if !this.Ids[i].Equal(&that1.Ids[i]) {
			return fmt.Errorf("Ids this[%v](%v) Not Equal that[%v](%v)", i, this.Ids[i], i, that1.Ids[i])
		}
	}
	if this.HallVersion != that1.HallVersion {
		return fmt.Errorf("HallVersion this(%v) Not Equal that(%v)", this.HallVersion, that1.HallVersion)
	}
	if this.AreaId != that1.AreaId {
		return fmt.Errorf("AreaId this(%v) Not Equal that(%v)", this.AreaId, that1.AreaId)
	}
	if this.IsNew != that1.IsNew {
		return fmt.Errorf("IsNew this(%v) Not Equal that(%v)", this.IsNew, that1.IsNew)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ListsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListsRequest)
	if !ok {
		that2, ok := that.(ListsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Cmd != that1.Cmd {
		return false
	}
	if this.App != that1.App {
		return false
	}
	if this.GameId != that1.GameId {
		return false
	}
	if this.Mid != that1.Mid {
		return false
	}
	if this.Ssid != that1.Ssid {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if this.Page != that1.Page {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Seq != that1.Seq {
		return false
	}
	if len(this.Ids) != len(that1.Ids) {
		return false
	}
	for i := range this.Ids {
		if !this.Ids[i].Equal(&that1.Ids[i]) {
			return false
		}
	}
	if this.HallVersion != that1.HallVersion {
		return false
	}
	if this.AreaId != that1.AreaId {
		return false
	}
	if this.IsNew != that1.IsNew {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ListsResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ListsResponse)
	if !ok {
		that2, ok := that.(ListsResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ListsResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ListsResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ListsResponse but is not nil && this == nil")
	}
	if this.Tpage != that1.Tpage {
		return fmt.Errorf("Tpage this(%v) Not Equal that(%v)", this.Tpage, that1.Tpage)
	}
	if this.Srvtime != that1.Srvtime {
		return fmt.Errorf("Srvtime this(%v) Not Equal that(%v)", this.Srvtime, that1.Srvtime)
	}
	if len(this.List) != len(that1.List) {
		return fmt.Errorf("List this(%v) Not Equal that(%v)", len(this.List), len(that1.List))
	}
	for i := range this.List {
		a := this.List[i]
		b := that1.List[i]
		if !(&a).Equal(&b) {
			return fmt.Errorf("List this[%v](%v) Not Equal that[%v](%v)", i, this.List[i], i, that1.List[i])
		}
	}
	if this.Filter != that1.Filter {
		return fmt.Errorf("Filter this(%v) Not Equal that(%v)", this.Filter, that1.Filter)
	}
	if this.Iconmax != that1.Iconmax {
		return fmt.Errorf("Iconmax this(%v) Not Equal that(%v)", this.Iconmax, that1.Iconmax)
	}
	if this.Pnum != that1.Pnum {
		return fmt.Errorf("Pnum this(%v) Not Equal that(%v)", this.Pnum, that1.Pnum)
	}
	if len(this.Apply) != len(that1.Apply) {
		return fmt.Errorf("Apply this(%v) Not Equal that(%v)", len(this.Apply), len(that1.Apply))
	}
	for i := range this.Apply {
		if this.Apply[i] != that1.Apply[i] {
			return fmt.Errorf("Apply this[%v](%v) Not Equal that[%v](%v)", i, this.Apply[i], i, that1.Apply[i])
		}
	}
	if len(this.Delete) != len(that1.Delete) {
		return fmt.Errorf("Delete this(%v) Not Equal that(%v)", len(this.Delete), len(that1.Delete))
	}
	for i := range this.Delete {
		a := this.Delete[i]
		b := that1.Delete[i]
		if !(&a).Equal(&b) {
			return fmt.Errorf("Delete this[%v](%v) Not Equal that[%v](%v)", i, this.Delete[i], i, that1.Delete[i])
		}
	}
	if len(this.Update) != len(that1.Update) {
		return fmt.Errorf("Update this(%v) Not Equal that(%v)", len(this.Update), len(that1.Update))
	}
	for i := range this.Update {
		a := this.Update[i]
		b := that1.Update[i]
		if !(&a).Equal(&b) {
			return fmt.Errorf("Update this[%v](%v) Not Equal that[%v](%v)", i, this.Update[i], i, that1.Update[i])
		}
	}
	if len(this.MatchIcons) != len(that1.MatchIcons) {
		return fmt.Errorf("MatchIcons this(%v) Not Equal that(%v)", len(this.MatchIcons), len(that1.MatchIcons))
	}
	for i := range this.MatchIcons {
		a := this.MatchIcons[i]
		b := that1.MatchIcons[i]
		if !(&a).Equal(&b) {
			return fmt.Errorf("MatchIcons this[%v](%v) Not Equal that[%v](%v)", i, this.MatchIcons[i], i, that1.MatchIcons[i])
		}
	}
	if len(this.Sort) != len(that1.Sort) {
		return fmt.Errorf("Sort this(%v) Not Equal that(%v)", len(this.Sort), len(that1.Sort))
	}
	for i := range this.Sort {
		if this.Sort[i] != that1.Sort[i] {
			return fmt.Errorf("Sort this[%v](%v) Not Equal that[%v](%v)", i, this.Sort[i], i, that1.Sort[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ListsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ListsResponse)
	if !ok {
		that2, ok := that.(ListsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Tpage != that1.Tpage {
		return false
	}
	if this.Srvtime != that1.Srvtime {
		return false
	}
	if len(this.List) != len(that1.List) {
		return false
	}
	for i := range this.List {
		a := this.List[i]
		b := that1.List[i]
		if !(&a).Equal(&b) {
			return false
		}
	}
	if this.Filter != that1.Filter {
		return false
	}
	if this.Iconmax != that1.Iconmax {
		return false
	}
	if this.Pnum != that1.Pnum {
		return false
	}
	if len(this.Apply) != len(that1.Apply) {
		return false
	}
	for i := range this.Apply {
		if this.Apply[i] != that1.Apply[i] {
			return false
		}
	}
	if len(this.Delete) != len(that1.Delete) {
		return false
	}
	for i := range this.Delete {
		a := this.Delete[i]
		b := that1.Delete[i]
		if !(&a).Equal(&b) {
			return false
		}
	}
	if len(this.Update) != len(that1.Update) {
		return false
	}
	for i := range this.Update {
		a := this.Update[i]
		b := that1.Update[i]
		if !(&a).Equal(&b) {
			return false
		}
	}
	if len(this.MatchIcons) != len(that1.MatchIcons) {
		return false
	}
	for i := range this.MatchIcons {
		a := this.MatchIcons[i]
		b := that1.MatchIcons[i]
		if !(&a).Equal(&b) {
			return false
		}
	}
	if len(this.Sort) != len(that1.Sort) {
		return false
	}
	for i := range this.Sort {
		if this.Sort[i] != that1.Sort[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Id) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Id)
	if !ok {
		that2, ok := that.(Id)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Id")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Id but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Id but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Configid != that1.Configid {
		return fmt.Errorf("Configid this(%v) Not Equal that(%v)", this.Configid, that1.Configid)
	}
	if this.Applynum != that1.Applynum {
		return fmt.Errorf("Applynum this(%v) Not Equal that(%v)", this.Applynum, that1.Applynum)
	}
	if this.Allapplynum != that1.Allapplynum {
		return fmt.Errorf("Allapplynum this(%v) Not Equal that(%v)", this.Allapplynum, that1.Allapplynum)
	}
	if this.Stime != that1.Stime {
		return fmt.Errorf("Stime this(%v) Not Equal that(%v)", this.Stime, that1.Stime)
	}
	if this.Etime != that1.Etime {
		return fmt.Errorf("Etime this(%v) Not Equal that(%v)", this.Etime, that1.Etime)
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if this.Matchpartitions != that1.Matchpartitions {
		return fmt.Errorf("Matchpartitions this(%v) Not Equal that(%v)", this.Matchpartitions, that1.Matchpartitions)
	}
	if this.FreeTimes != that1.FreeTimes {
		return fmt.Errorf("FreeTimes this(%v) Not Equal that(%v)", this.FreeTimes, that1.FreeTimes)
	}
	if this.AllFreeTimes != that1.AllFreeTimes {
		return fmt.Errorf("AllFreeTimes this(%v) Not Equal that(%v)", this.AllFreeTimes, that1.AllFreeTimes)
	}
	if this.AllDiscountNum != that1.AllDiscountNum {
		return fmt.Errorf("AllDiscountNum this(%v) Not Equal that(%v)", this.AllDiscountNum, that1.AllDiscountNum)
	}
	if this.RemainDiscountNum != that1.RemainDiscountNum {
		return fmt.Errorf("RemainDiscountNum this(%v) Not Equal that(%v)", this.RemainDiscountNum, that1.RemainDiscountNum)
	}
	if len(this.Fee) != len(that1.Fee) {
		return fmt.Errorf("Fee this(%v) Not Equal that(%v)", len(this.Fee), len(that1.Fee))
	}
	for i := range this.Fee {
		if !this.Fee[i].Equal(&that1.Fee[i]) {
			return fmt.Errorf("Fee this[%v](%v) Not Equal that[%v](%v)", i, this.Fee[i], i, that1.Fee[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Id) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Id)
	if !ok {
		that2, ok := that.(Id)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Configid != that1.Configid {
		return false
	}
	if this.Applynum != that1.Applynum {
		return false
	}
	if this.Allapplynum != that1.Allapplynum {
		return false
	}
	if this.Stime != that1.Stime {
		return false
	}
	if this.Etime != that1.Etime {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Matchpartitions != that1.Matchpartitions {
		return false
	}
	if this.FreeTimes != that1.FreeTimes {
		return false
	}
	if this.AllFreeTimes != that1.AllFreeTimes {
		return false
	}
	if this.AllDiscountNum != that1.AllDiscountNum {
		return false
	}
	if this.RemainDiscountNum != that1.RemainDiscountNum {
		return false
	}
	if len(this.Fee) != len(that1.Fee) {
		return false
	}
	for i := range this.Fee {
		if !this.Fee[i].Equal(&that1.Fee[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *MatchIcon) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*MatchIcon)
	if !ok {
		that2, ok := that.(MatchIcon)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *MatchIcon")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *MatchIcon but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *MatchIcon but is not nil && this == nil")
	}
	if this.Icon != that1.Icon {
		return fmt.Errorf("Icon this(%v) Not Equal that(%v)", this.Icon, that1.Icon)
	}
	if this.Color != that1.Color {
		return fmt.Errorf("Color this(%v) Not Equal that(%v)", this.Color, that1.Color)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *MatchIcon) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchIcon)
	if !ok {
		that2, ok := that.(MatchIcon)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Icon != that1.Icon {
		return false
	}
	if this.Color != that1.Color {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *List) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*List)
	if !ok {
		that2, ok := that.(List)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *List")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *List but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *List but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Mname != that1.Mname {
		return fmt.Errorf("Mname this(%v) Not Equal that(%v)", this.Mname, that1.Mname)
	}
	if this.Micon != that1.Micon {
		return fmt.Errorf("Micon this(%v) Not Equal that(%v)", this.Micon, that1.Micon)
	}
	if this.Iconweight != that1.Iconweight {
		return fmt.Errorf("Iconweight this(%v) Not Equal that(%v)", this.Iconweight, that1.Iconweight)
	}
	if this.AdIcon != that1.AdIcon {
		return fmt.Errorf("AdIcon this(%v) Not Equal that(%v)", this.AdIcon, that1.AdIcon)
	}
	if this.ListSort != that1.ListSort {
		return fmt.Errorf("ListSort this(%v) Not Equal that(%v)", this.ListSort, that1.ListSort)
	}
	if this.Stime != that1.Stime {
		return fmt.Errorf("Stime this(%v) Not Equal that(%v)", this.Stime, that1.Stime)
	}
	if this.Etime != that1.Etime {
		return fmt.Errorf("Etime this(%v) Not Equal that(%v)", this.Etime, that1.Etime)
	}
	if this.Gameid != that1.Gameid {
		return fmt.Errorf("Gameid this(%v) Not Equal that(%v)", this.Gameid, that1.Gameid)
	}
	if this.Gamesort != that1.Gamesort {
		return fmt.Errorf("Gamesort this(%v) Not Equal that(%v)", this.Gamesort, that1.Gamesort)
	}
	if this.Requestnum != that1.Requestnum {
		return fmt.Errorf("Requestnum this(%v) Not Equal that(%v)", this.Requestnum, that1.Requestnum)
	}
	if this.Applynum != that1.Applynum {
		return fmt.Errorf("Applynum this(%v) Not Equal that(%v)", this.Applynum, that1.Applynum)
	}
	if this.Allowwaittime != that1.Allowwaittime {
		return fmt.Errorf("Allowwaittime this(%v) Not Equal that(%v)", this.Allowwaittime, that1.Allowwaittime)
	}
	if this.Champion != that1.Champion {
		return fmt.Errorf("Champion this(%v) Not Equal that(%v)", this.Champion, that1.Champion)
	}
	if len(this.Fee) != len(that1.Fee) {
		return fmt.Errorf("Fee this(%v) Not Equal that(%v)", len(this.Fee), len(that1.Fee))
	}
	for i := range this.Fee {
		if !this.Fee[i].Equal(&that1.Fee[i]) {
			return fmt.Errorf("Fee this[%v](%v) Not Equal that[%v](%v)", i, this.Fee[i], i, that1.Fee[i])
		}
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if this.Looptype != that1.Looptype {
		return fmt.Errorf("Looptype this(%v) Not Equal that(%v)", this.Looptype, that1.Looptype)
	}
	if this.Loopinterval != that1.Loopinterval {
		return fmt.Errorf("Loopinterval this(%v) Not Equal that(%v)", this.Loopinterval, that1.Loopinterval)
	}
	if this.Loopendtime != that1.Loopendtime {
		return fmt.Errorf("Loopendtime this(%v) Not Equal that(%v)", this.Loopendtime, that1.Loopendtime)
	}
	if this.RewardUrl != that1.RewardUrl {
		return fmt.Errorf("RewardUrl this(%v) Not Equal that(%v)", this.RewardUrl, that1.RewardUrl)
	}
	if this.RewardDescribe != that1.RewardDescribe {
		return fmt.Errorf("RewardDescribe this(%v) Not Equal that(%v)", this.RewardDescribe, that1.RewardDescribe)
	}
	if this.ThresholdType != that1.ThresholdType {
		return fmt.Errorf("ThresholdType this(%v) Not Equal that(%v)", this.ThresholdType, that1.ThresholdType)
	}
	if this.Threshold != that1.Threshold {
		return fmt.Errorf("Threshold this(%v) Not Equal that(%v)", this.Threshold, that1.Threshold)
	}
	if this.Configid != that1.Configid {
		return fmt.Errorf("Configid this(%v) Not Equal that(%v)", this.Configid, that1.Configid)
	}
	if this.Matchtags != that1.Matchtags {
		return fmt.Errorf("Matchtags this(%v) Not Equal that(%v)", this.Matchtags, that1.Matchtags)
	}
	if this.Matchentrycode != that1.Matchentrycode {
		return fmt.Errorf("Matchentrycode this(%v) Not Equal that(%v)", this.Matchentrycode, that1.Matchentrycode)
	}
	if this.Matchentryinfo != that1.Matchentryinfo {
		return fmt.Errorf("Matchentryinfo this(%v) Not Equal that(%v)", this.Matchentryinfo, that1.Matchentryinfo)
	}
	if this.Sname != that1.Sname {
		return fmt.Errorf("Sname this(%v) Not Equal that(%v)", this.Sname, that1.Sname)
	}
	if this.Gamename != that1.Gamename {
		return fmt.Errorf("Gamename this(%v) Not Equal that(%v)", this.Gamename, that1.Gamename)
	}
	if this.Advicon != that1.Advicon {
		return fmt.Errorf("Advicon this(%v) Not Equal that(%v)", this.Advicon, that1.Advicon)
	}
	if this.Maxawardpool != that1.Maxawardpool {
		return fmt.Errorf("Maxawardpool this(%v) Not Equal that(%v)", this.Maxawardpool, that1.Maxawardpool)
	}
	if len(this.Mclabel) != len(that1.Mclabel) {
		return fmt.Errorf("Mclabel this(%v) Not Equal that(%v)", len(this.Mclabel), len(that1.Mclabel))
	}
	for i := range this.Mclabel {
		if this.Mclabel[i] != that1.Mclabel[i] {
			return fmt.Errorf("Mclabel this[%v](%v) Not Equal that[%v](%v)", i, this.Mclabel[i], i, that1.Mclabel[i])
		}
	}
	if this.Allapplynum != that1.Allapplynum {
		return fmt.Errorf("Allapplynum this(%v) Not Equal that(%v)", this.Allapplynum, that1.Allapplynum)
	}
	if this.AllFreeTimes != that1.AllFreeTimes {
		return fmt.Errorf("AllFreeTimes this(%v) Not Equal that(%v)", this.AllFreeTimes, that1.AllFreeTimes)
	}
	if this.FreeTimes != that1.FreeTimes {
		return fmt.Errorf("FreeTimes this(%v) Not Equal that(%v)", this.FreeTimes, that1.FreeTimes)
	}
	if len(this.Moneylimit) != len(that1.Moneylimit) {
		return fmt.Errorf("Moneylimit this(%v) Not Equal that(%v)", len(this.Moneylimit), len(that1.Moneylimit))
	}
	for i := range this.Moneylimit {
		if this.Moneylimit[i] != that1.Moneylimit[i] {
			return fmt.Errorf("Moneylimit this[%v](%v) Not Equal that[%v](%v)", i, this.Moneylimit[i], i, that1.Moneylimit[i])
		}
	}
	if this.Recommendmatchcfgid != that1.Recommendmatchcfgid {
		return fmt.Errorf("Recommendmatchcfgid this(%v) Not Equal that(%v)", this.Recommendmatchcfgid, that1.Recommendmatchcfgid)
	}
	if this.Endtime != that1.Endtime {
		return fmt.Errorf("Endtime this(%v) Not Equal that(%v)", this.Endtime, that1.Endtime)
	}
	if this.Matchpartitions != that1.Matchpartitions {
		return fmt.Errorf("Matchpartitions this(%v) Not Equal that(%v)", this.Matchpartitions, that1.Matchpartitions)
	}
	if this.Isfhmatch != that1.Isfhmatch {
		return fmt.Errorf("Isfhmatch this(%v) Not Equal that(%v)", this.Isfhmatch, that1.Isfhmatch)
	}
	if this.Loopintervaltime != that1.Loopintervaltime {
		return fmt.Errorf("Loopintervaltime this(%v) Not Equal that(%v)", this.Loopintervaltime, that1.Loopintervaltime)
	}
	if this.Firstbegintime != that1.Firstbegintime {
		return fmt.Errorf("Firstbegintime this(%v) Not Equal that(%v)", this.Firstbegintime, that1.Firstbegintime)
	}
	if this.DiscountPrice != that1.DiscountPrice {
		return fmt.Errorf("DiscountPrice this(%v) Not Equal that(%v)", this.DiscountPrice, that1.DiscountPrice)
	}
	if this.DiscountType != that1.DiscountType {
		return fmt.Errorf("DiscountType this(%v) Not Equal that(%v)", this.DiscountType, that1.DiscountType)
	}
	if this.AllDiscountNum != that1.AllDiscountNum {
		return fmt.Errorf("AllDiscountNum this(%v) Not Equal that(%v)", this.AllDiscountNum, that1.AllDiscountNum)
	}
	if this.RemainDiscountNum != that1.RemainDiscountNum {
		return fmt.Errorf("RemainDiscountNum this(%v) Not Equal that(%v)", this.RemainDiscountNum, that1.RemainDiscountNum)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *List) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*List)
	if !ok {
		that2, ok := that.(List)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Mname != that1.Mname {
		return false
	}
	if this.Micon != that1.Micon {
		return false
	}
	if this.Iconweight != that1.Iconweight {
		return false
	}
	if this.AdIcon != that1.AdIcon {
		return false
	}
	if this.ListSort != that1.ListSort {
		return false
	}
	if this.Stime != that1.Stime {
		return false
	}
	if this.Etime != that1.Etime {
		return false
	}
	if this.Gameid != that1.Gameid {
		return false
	}
	if this.Gamesort != that1.Gamesort {
		return false
	}
	if this.Requestnum != that1.Requestnum {
		return false
	}
	if this.Applynum != that1.Applynum {
		return false
	}
	if this.Allowwaittime != that1.Allowwaittime {
		return false
	}
	if this.Champion != that1.Champion {
		return false
	}
	if len(this.Fee) != len(that1.Fee) {
		return false
	}
	for i := range this.Fee {
		if !this.Fee[i].Equal(&that1.Fee[i]) {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Looptype != that1.Looptype {
		return false
	}
	if this.Loopinterval != that1.Loopinterval {
		return false
	}
	if this.Loopendtime != that1.Loopendtime {
		return false
	}
	if this.RewardUrl != that1.RewardUrl {
		return false
	}
	if this.RewardDescribe != that1.RewardDescribe {
		return false
	}
	if this.ThresholdType != that1.ThresholdType {
		return false
	}
	if this.Threshold != that1.Threshold {
		return false
	}
	if this.Configid != that1.Configid {
		return false
	}
	if this.Matchtags != that1.Matchtags {
		return false
	}
	if this.Matchentrycode != that1.Matchentrycode {
		return false
	}
	if this.Matchentryinfo != that1.Matchentryinfo {
		return false
	}
	if this.Sname != that1.Sname {
		return false
	}
	if this.Gamename != that1.Gamename {
		return false
	}
	if this.Advicon != that1.Advicon {
		return false
	}
	if this.Maxawardpool != that1.Maxawardpool {
		return false
	}
	if len(this.Mclabel) != len(that1.Mclabel) {
		return false
	}
	for i := range this.Mclabel {
		if this.Mclabel[i] != that1.Mclabel[i] {
			return false
		}
	}
	if this.Allapplynum != that1.Allapplynum {
		return false
	}
	if this.AllFreeTimes != that1.AllFreeTimes {
		return false
	}
	if this.FreeTimes != that1.FreeTimes {
		return false
	}
	if len(this.Moneylimit) != len(that1.Moneylimit) {
		return false
	}
	for i := range this.Moneylimit {
		if this.Moneylimit[i] != that1.Moneylimit[i] {
			return false
		}
	}
	if this.Recommendmatchcfgid != that1.Recommendmatchcfgid {
		return false
	}
	if this.Endtime != that1.Endtime {
		return false
	}
	if this.Matchpartitions != that1.Matchpartitions {
		return false
	}
	if this.Isfhmatch != that1.Isfhmatch {
		return false
	}
	if this.Loopintervaltime != that1.Loopintervaltime {
		return false
	}
	if this.Firstbegintime != that1.Firstbegintime {
		return false
	}
	if this.DiscountPrice != that1.DiscountPrice {
		return false
	}
	if this.DiscountType != that1.DiscountType {
		return false
	}
	if this.AllDiscountNum != that1.AllDiscountNum {
		return false
	}
	if this.RemainDiscountNum != that1.RemainDiscountNum {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Fee) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Fee)
	if !ok {
		that2, ok := that.(Fee)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Fee")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Fee but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Fee but is not nil && this == nil")
	}
	if len(this.Subfee) != len(that1.Subfee) {
		return fmt.Errorf("Subfee this(%v) Not Equal that(%v)", len(this.Subfee), len(that1.Subfee))
	}
	for i := range this.Subfee {
		if !this.Subfee[i].Equal(&that1.Subfee[i]) {
			return fmt.Errorf("Subfee this[%v](%v) Not Equal that[%v](%v)", i, this.Subfee[i], i, that1.Subfee[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Fee) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Fee)
	if !ok {
		that2, ok := that.(Fee)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Subfee) != len(that1.Subfee) {
		return false
	}
	for i := range this.Subfee {
		if !this.Subfee[i].Equal(&that1.Subfee[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *SubFee) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SubFee)
	if !ok {
		that2, ok := that.(SubFee)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SubFee")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SubFee but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SubFee but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Num != that1.Num {
		return fmt.Errorf("Num this(%v) Not Equal that(%v)", this.Num, that1.Num)
	}
	if this.Desc != that1.Desc {
		return fmt.Errorf("Desc this(%v) Not Equal that(%v)", this.Desc, that1.Desc)
	}
	if this.Label != that1.Label {
		return fmt.Errorf("Label this(%v) Not Equal that(%v)", this.Label, that1.Label)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *SubFee) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubFee)
	if !ok {
		that2, ok := that.(SubFee)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Num != that1.Num {
		return false
	}
	if this.Desc != that1.Desc {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ListsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&proto.ListsRequest{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "App: "+fmt.Sprintf("%#v", this.App)+",\n")
	s = append(s, "GameId: "+fmt.Sprintf("%#v", this.GameId)+",\n")
	s = append(s, "Mid: "+fmt.Sprintf("%#v", this.Mid)+",\n")
	s = append(s, "Ssid: "+fmt.Sprintf("%#v", this.Ssid)+",\n")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "Page: "+fmt.Sprintf("%#v", this.Page)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Seq: "+fmt.Sprintf("%#v", this.Seq)+",\n")
	if this.Ids != nil {
		vs := make([]*List, len(this.Ids))
		for i := range vs {
			vs[i] = &this.Ids[i]
		}
		s = append(s, "Ids: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "HallVersion: "+fmt.Sprintf("%#v", this.HallVersion)+",\n")
	s = append(s, "AreaId: "+fmt.Sprintf("%#v", this.AreaId)+",\n")
	s = append(s, "IsNew: "+fmt.Sprintf("%#v", this.IsNew)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ListsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&proto.ListsResponse{")
	s = append(s, "Tpage: "+fmt.Sprintf("%#v", this.Tpage)+",\n")
	s = append(s, "Srvtime: "+fmt.Sprintf("%#v", this.Srvtime)+",\n")
	keysForList := make([]uint32, 0, len(this.List))
	for k, _ := range this.List {
		keysForList = append(keysForList, k)
	}
	sortkeys.Uint32s(keysForList)
	mapStringForList := "map[uint32]List{"
	for _, k := range keysForList {
		mapStringForList += fmt.Sprintf("%#v: %#v,", k, this.List[k])
	}
	mapStringForList += "}"
	if this.List != nil {
		s = append(s, "List: "+mapStringForList+",\n")
	}
	s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	s = append(s, "Iconmax: "+fmt.Sprintf("%#v", this.Iconmax)+",\n")
	s = append(s, "Pnum: "+fmt.Sprintf("%#v", this.Pnum)+",\n")
	if this.Apply != nil {
		s = append(s, "Apply: "+fmt.Sprintf("%#v", this.Apply)+",\n")
	}
	keysForDelete := make([]uint32, 0, len(this.Delete))
	for k, _ := range this.Delete {
		keysForDelete = append(keysForDelete, k)
	}
	sortkeys.Uint32s(keysForDelete)
	mapStringForDelete := "map[uint32]List{"
	for _, k := range keysForDelete {
		mapStringForDelete += fmt.Sprintf("%#v: %#v,", k, this.Delete[k])
	}
	mapStringForDelete += "}"
	if this.Delete != nil {
		s = append(s, "Delete: "+mapStringForDelete+",\n")
	}
	keysForUpdate := make([]uint32, 0, len(this.Update))
	for k, _ := range this.Update {
		keysForUpdate = append(keysForUpdate, k)
	}
	sortkeys.Uint32s(keysForUpdate)
	mapStringForUpdate := "map[uint32]List{"
	for _, k := range keysForUpdate {
		mapStringForUpdate += fmt.Sprintf("%#v: %#v,", k, this.Update[k])
	}
	mapStringForUpdate += "}"
	if this.Update != nil {
		s = append(s, "Update: "+mapStringForUpdate+",\n")
	}
	keysForMatchIcons := make([]string, 0, len(this.MatchIcons))
	for k, _ := range this.MatchIcons {
		keysForMatchIcons = append(keysForMatchIcons, k)
	}
	sortkeys.Strings(keysForMatchIcons)
	mapStringForMatchIcons := "map[string]MatchIcon{"
	for _, k := range keysForMatchIcons {
		mapStringForMatchIcons += fmt.Sprintf("%#v: %#v,", k, this.MatchIcons[k])
	}
	mapStringForMatchIcons += "}"
	if this.MatchIcons != nil {
		s = append(s, "MatchIcons: "+mapStringForMatchIcons+",\n")
	}
	keysForSort := make([]string, 0, len(this.Sort))
	for k, _ := range this.Sort {
		keysForSort = append(keysForSort, k)
	}
	sortkeys.Strings(keysForSort)
	mapStringForSort := "map[string]uint32{"
	for _, k := range keysForSort {
		mapStringForSort += fmt.Sprintf("%#v: %#v,", k, this.Sort[k])
	}
	mapStringForSort += "}"
	if this.Sort != nil {
		s = append(s, "Sort: "+mapStringForSort+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Id) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&proto.Id{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Configid: "+fmt.Sprintf("%#v", this.Configid)+",\n")
	s = append(s, "Applynum: "+fmt.Sprintf("%#v", this.Applynum)+",\n")
	s = append(s, "Allapplynum: "+fmt.Sprintf("%#v", this.Allapplynum)+",\n")
	s = append(s, "Stime: "+fmt.Sprintf("%#v", this.Stime)+",\n")
	s = append(s, "Etime: "+fmt.Sprintf("%#v", this.Etime)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Matchpartitions: "+fmt.Sprintf("%#v", this.Matchpartitions)+",\n")
	s = append(s, "FreeTimes: "+fmt.Sprintf("%#v", this.FreeTimes)+",\n")
	s = append(s, "AllFreeTimes: "+fmt.Sprintf("%#v", this.AllFreeTimes)+",\n")
	s = append(s, "AllDiscountNum: "+fmt.Sprintf("%#v", this.AllDiscountNum)+",\n")
	s = append(s, "RemainDiscountNum: "+fmt.Sprintf("%#v", this.RemainDiscountNum)+",\n")
	if this.Fee != nil {
		vs := make([]*Fee, len(this.Fee))
		for i := range vs {
			vs[i] = &this.Fee[i]
		}
		s = append(s, "Fee: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MatchIcon) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&proto.MatchIcon{")
	s = append(s, "Icon: "+fmt.Sprintf("%#v", this.Icon)+",\n")
	s = append(s, "Color: "+fmt.Sprintf("%#v", this.Color)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *List) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 51)
	s = append(s, "&proto.List{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Mname: "+fmt.Sprintf("%#v", this.Mname)+",\n")
	s = append(s, "Micon: "+fmt.Sprintf("%#v", this.Micon)+",\n")
	s = append(s, "Iconweight: "+fmt.Sprintf("%#v", this.Iconweight)+",\n")
	s = append(s, "AdIcon: "+fmt.Sprintf("%#v", this.AdIcon)+",\n")
	s = append(s, "ListSort: "+fmt.Sprintf("%#v", this.ListSort)+",\n")
	s = append(s, "Stime: "+fmt.Sprintf("%#v", this.Stime)+",\n")
	s = append(s, "Etime: "+fmt.Sprintf("%#v", this.Etime)+",\n")
	s = append(s, "Gameid: "+fmt.Sprintf("%#v", this.Gameid)+",\n")
	s = append(s, "Gamesort: "+fmt.Sprintf("%#v", this.Gamesort)+",\n")
	s = append(s, "Requestnum: "+fmt.Sprintf("%#v", this.Requestnum)+",\n")
	s = append(s, "Applynum: "+fmt.Sprintf("%#v", this.Applynum)+",\n")
	s = append(s, "Allowwaittime: "+fmt.Sprintf("%#v", this.Allowwaittime)+",\n")
	s = append(s, "Champion: "+fmt.Sprintf("%#v", this.Champion)+",\n")
	if this.Fee != nil {
		vs := make([]*Fee, len(this.Fee))
		for i := range vs {
			vs[i] = &this.Fee[i]
		}
		s = append(s, "Fee: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Looptype: "+fmt.Sprintf("%#v", this.Looptype)+",\n")
	s = append(s, "Loopinterval: "+fmt.Sprintf("%#v", this.Loopinterval)+",\n")
	s = append(s, "Loopendtime: "+fmt.Sprintf("%#v", this.Loopendtime)+",\n")
	s = append(s, "RewardUrl: "+fmt.Sprintf("%#v", this.RewardUrl)+",\n")
	s = append(s, "RewardDescribe: "+fmt.Sprintf("%#v", this.RewardDescribe)+",\n")
	s = append(s, "ThresholdType: "+fmt.Sprintf("%#v", this.ThresholdType)+",\n")
	s = append(s, "Threshold: "+fmt.Sprintf("%#v", this.Threshold)+",\n")
	s = append(s, "Configid: "+fmt.Sprintf("%#v", this.Configid)+",\n")
	s = append(s, "Matchtags: "+fmt.Sprintf("%#v", this.Matchtags)+",\n")
	s = append(s, "Matchentrycode: "+fmt.Sprintf("%#v", this.Matchentrycode)+",\n")
	s = append(s, "Matchentryinfo: "+fmt.Sprintf("%#v", this.Matchentryinfo)+",\n")
	s = append(s, "Sname: "+fmt.Sprintf("%#v", this.Sname)+",\n")
	s = append(s, "Gamename: "+fmt.Sprintf("%#v", this.Gamename)+",\n")
	s = append(s, "Advicon: "+fmt.Sprintf("%#v", this.Advicon)+",\n")
	s = append(s, "Maxawardpool: "+fmt.Sprintf("%#v", this.Maxawardpool)+",\n")
	keysForMclabel := make([]string, 0, len(this.Mclabel))
	for k, _ := range this.Mclabel {
		keysForMclabel = append(keysForMclabel, k)
	}
	sortkeys.Strings(keysForMclabel)
	mapStringForMclabel := "map[string]string{"
	for _, k := range keysForMclabel {
		mapStringForMclabel += fmt.Sprintf("%#v: %#v,", k, this.Mclabel[k])
	}
	mapStringForMclabel += "}"
	if this.Mclabel != nil {
		s = append(s, "Mclabel: "+mapStringForMclabel+",\n")
	}
	s = append(s, "Allapplynum: "+fmt.Sprintf("%#v", this.Allapplynum)+",\n")
	s = append(s, "AllFreeTimes: "+fmt.Sprintf("%#v", this.AllFreeTimes)+",\n")
	s = append(s, "FreeTimes: "+fmt.Sprintf("%#v", this.FreeTimes)+",\n")
	keysForMoneylimit := make([]string, 0, len(this.Moneylimit))
	for k, _ := range this.Moneylimit {
		keysForMoneylimit = append(keysForMoneylimit, k)
	}
	sortkeys.Strings(keysForMoneylimit)
	mapStringForMoneylimit := "map[string]string{"
	for _, k := range keysForMoneylimit {
		mapStringForMoneylimit += fmt.Sprintf("%#v: %#v,", k, this.Moneylimit[k])
	}
	mapStringForMoneylimit += "}"
	if this.Moneylimit != nil {
		s = append(s, "Moneylimit: "+mapStringForMoneylimit+",\n")
	}
	s = append(s, "Recommendmatchcfgid: "+fmt.Sprintf("%#v", this.Recommendmatchcfgid)+",\n")
	s = append(s, "Endtime: "+fmt.Sprintf("%#v", this.Endtime)+",\n")
	s = append(s, "Matchpartitions: "+fmt.Sprintf("%#v", this.Matchpartitions)+",\n")
	s = append(s, "Isfhmatch: "+fmt.Sprintf("%#v", this.Isfhmatch)+",\n")
	s = append(s, "Loopintervaltime: "+fmt.Sprintf("%#v", this.Loopintervaltime)+",\n")
	s = append(s, "Firstbegintime: "+fmt.Sprintf("%#v", this.Firstbegintime)+",\n")
	s = append(s, "DiscountPrice: "+fmt.Sprintf("%#v", this.DiscountPrice)+",\n")
	s = append(s, "DiscountType: "+fmt.Sprintf("%#v", this.DiscountType)+",\n")
	s = append(s, "AllDiscountNum: "+fmt.Sprintf("%#v", this.AllDiscountNum)+",\n")
	s = append(s, "RemainDiscountNum: "+fmt.Sprintf("%#v", this.RemainDiscountNum)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Fee) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&proto.Fee{")
	if this.Subfee != nil {
		vs := make([]*SubFee, len(this.Subfee))
		for i := range vs {
			vs[i] = &this.Subfee[i]
		}
		s = append(s, "Subfee: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubFee) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&proto.SubFee{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Num: "+fmt.Sprintf("%#v", this.Num)+",\n")
	s = append(s, "Desc: "+fmt.Sprintf("%#v", this.Desc)+",\n")
	s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMatch(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ListsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Cmd))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.App))
	dAtA[i] = 0x18
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.GameId))
	dAtA[i] = 0x20
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Mid))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Ssid)))
	i += copy(dAtA[i:], m.Ssid)
	dAtA[i] = 0x32
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Action)))
	i += copy(dAtA[i:], m.Action)
	dAtA[i] = 0x38
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Page))
	dAtA[i] = 0x40
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Timestamp))
	dAtA[i] = 0x48
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Seq))
	if len(m.Ids) > 0 {
		for _, msg := range m.Ids {
			dAtA[i] = 0x52
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x58
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.HallVersion))
	dAtA[i] = 0x60
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.AreaId))
	dAtA[i] = 0x68
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.IsNew))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ListsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Tpage))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Srvtime))
	if len(m.List) > 0 {
		for k, _ := range m.List {
			dAtA[i] = 0x1a
			i++
			v := m.List[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovMatch(uint64(msgSize))
			}
			mapSize := 1 + sovMatch(uint64(k)) + msgSize
			i = encodeVarintMatch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMatch(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintMatch(dAtA, i, uint64((&v).Size()))
			n1, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n1
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Filter))
	dAtA[i] = 0x28
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Iconmax))
	dAtA[i] = 0x30
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Pnum))
	if len(m.Apply) > 0 {
		for _, num := range m.Apply {
			dAtA[i] = 0x38
			i++
			i = encodeVarintMatch(dAtA, i, uint64(num))
		}
	}
	if len(m.Delete) > 0 {
		for k, _ := range m.Delete {
			dAtA[i] = 0x42
			i++
			v := m.Delete[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovMatch(uint64(msgSize))
			}
			mapSize := 1 + sovMatch(uint64(k)) + msgSize
			i = encodeVarintMatch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMatch(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintMatch(dAtA, i, uint64((&v).Size()))
			n2, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n2
		}
	}
	if len(m.Update) > 0 {
		for k, _ := range m.Update {
			dAtA[i] = 0x4a
			i++
			v := m.Update[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovMatch(uint64(msgSize))
			}
			mapSize := 1 + sovMatch(uint64(k)) + msgSize
			i = encodeVarintMatch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMatch(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintMatch(dAtA, i, uint64((&v).Size()))
			n3, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n3
		}
	}
	if len(m.MatchIcons) > 0 {
		for k, _ := range m.MatchIcons {
			dAtA[i] = 0x52
			i++
			v := m.MatchIcons[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovMatch(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovMatch(uint64(len(k))) + msgSize
			i = encodeVarintMatch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMatch(dAtA, i, uint64((&v).Size()))
			n4, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n4
		}
	}
	if len(m.Sort) > 0 {
		for k, _ := range m.Sort {
			dAtA[i] = 0x5a
			i++
			v := m.Sort[k]
			mapSize := 1 + len(k) + sovMatch(uint64(len(k))) + 1 + sovMatch(uint64(v))
			i = encodeVarintMatch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintMatch(dAtA, i, uint64(v))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Id) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Id) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x18
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Configid))
	dAtA[i] = 0x20
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Applynum))
	dAtA[i] = 0x28
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Allapplynum))
	dAtA[i] = 0x30
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Stime))
	dAtA[i] = 0x38
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Etime))
	dAtA[i] = 0x40
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Status))
	dAtA[i] = 0x48
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Matchpartitions))
	dAtA[i] = 0x50
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.FreeTimes))
	dAtA[i] = 0x58
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.AllFreeTimes))
	dAtA[i] = 0x60
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.AllDiscountNum))
	dAtA[i] = 0x68
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.RemainDiscountNum))
	if len(m.Fee) > 0 {
		for _, msg := range m.Fee {
			dAtA[i] = 0x72
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MatchIcon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchIcon) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Icon)))
	i += copy(dAtA[i:], m.Icon)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Color)))
	i += copy(dAtA[i:], m.Color)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *List) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Mname)))
	i += copy(dAtA[i:], m.Mname)
	dAtA[i] = 0x22
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Micon)))
	i += copy(dAtA[i:], m.Micon)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Iconweight)))
	i += copy(dAtA[i:], m.Iconweight)
	dAtA[i] = 0x32
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.AdIcon)))
	i += copy(dAtA[i:], m.AdIcon)
	dAtA[i] = 0x3a
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.ListSort)))
	i += copy(dAtA[i:], m.ListSort)
	dAtA[i] = 0x40
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Stime))
	dAtA[i] = 0x48
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Etime))
	dAtA[i] = 0x50
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Gameid))
	dAtA[i] = 0x58
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Gamesort))
	dAtA[i] = 0x62
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Requestnum)))
	i += copy(dAtA[i:], m.Requestnum)
	dAtA[i] = 0x68
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Applynum))
	dAtA[i] = 0x70
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Allowwaittime))
	dAtA[i] = 0x7a
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Champion)))
	i += copy(dAtA[i:], m.Champion)
	if len(m.Fee) > 0 {
		for _, msg := range m.Fee {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Status))
	dAtA[i] = 0x90
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Looptype))
	dAtA[i] = 0x9d
	i++
	dAtA[i] = 0x1
	i++
	binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Loopinterval))))
	i += 4
	dAtA[i] = 0xa2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Loopendtime)))
	i += copy(dAtA[i:], m.Loopendtime)
	dAtA[i] = 0xaa
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.RewardUrl)))
	i += copy(dAtA[i:], m.RewardUrl)
	dAtA[i] = 0xb2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.RewardDescribe)))
	i += copy(dAtA[i:], m.RewardDescribe)
	dAtA[i] = 0xb9
	i++
	dAtA[i] = 0x1
	i++
	binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ThresholdType))))
	i += 8
	dAtA[i] = 0xc1
	i++
	dAtA[i] = 0x1
	i++
	binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Threshold))))
	i += 8
	dAtA[i] = 0xca
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Configid)))
	i += copy(dAtA[i:], m.Configid)
	dAtA[i] = 0xd2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Matchtags)))
	i += copy(dAtA[i:], m.Matchtags)
	dAtA[i] = 0xda
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Matchentrycode)))
	i += copy(dAtA[i:], m.Matchentrycode)
	dAtA[i] = 0xe2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Matchentryinfo)))
	i += copy(dAtA[i:], m.Matchentryinfo)
	dAtA[i] = 0xea
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Sname)))
	i += copy(dAtA[i:], m.Sname)
	dAtA[i] = 0xf2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Gamename)))
	i += copy(dAtA[i:], m.Gamename)
	dAtA[i] = 0xfa
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Advicon)))
	i += copy(dAtA[i:], m.Advicon)
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Maxawardpool))
	if len(m.Mclabel) > 0 {
		for k, _ := range m.Mclabel {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x2
			i++
			v := m.Mclabel[k]
			mapSize := 1 + len(k) + sovMatch(uint64(len(k))) + 1 + len(v) + sovMatch(uint64(len(v)))
			i = encodeVarintMatch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMatch(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	dAtA[i] = 0x90
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Allapplynum))
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.AllFreeTimes))
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.FreeTimes))
	if len(m.Moneylimit) > 0 {
		for k, _ := range m.Moneylimit {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x2
			i++
			v := m.Moneylimit[k]
			mapSize := 1 + len(k) + sovMatch(uint64(len(k))) + 1 + len(v) + sovMatch(uint64(len(v)))
			i = encodeVarintMatch(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatch(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMatch(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	dAtA[i] = 0xb0
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Recommendmatchcfgid))
	dAtA[i] = 0xb8
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Endtime))
	dAtA[i] = 0xc0
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Matchpartitions))
	dAtA[i] = 0xc9
	i++
	dAtA[i] = 0x2
	i++
	binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Isfhmatch))))
	i += 8
	dAtA[i] = 0xd0
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Loopintervaltime))
	dAtA[i] = 0xd8
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Firstbegintime))
	dAtA[i] = 0xe0
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.DiscountPrice))
	dAtA[i] = 0xe8
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.DiscountType))
	dAtA[i] = 0xf0
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.AllDiscountNum))
	dAtA[i] = 0xf8
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.RemainDiscountNum))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Fee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fee) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Subfee) > 0 {
		for _, msg := range m.Subfee {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatch(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SubFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubFee) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Num))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMatch(dAtA, i, uint64(len(m.Desc)))
	i += copy(dAtA[i:], m.Desc)
	dAtA[i] = 0x20
	i++
	i = encodeVarintMatch(dAtA, i, uint64(m.Label))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMatch(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedListsRequest(r randyMatch, easy bool) *ListsRequest {
	this := &ListsRequest{}
	this.Cmd = uint64(uint64(r.Uint32()))
	this.App = uint64(uint64(r.Uint32()))
	this.GameId = uint64(uint64(r.Uint32()))
	this.Mid = uint64(uint64(r.Uint32()))
	this.Ssid = string(randStringMatch(r))
	this.Action = string(randStringMatch(r))
	this.Page = uint32(r.Uint32())
	this.Timestamp = uint64(uint64(r.Uint32()))
	this.Seq = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Ids = make([]List, v1)
		for i := 0; i < v1; i++ {
			v2 := NewPopulatedList(r, easy)
			this.Ids[i] = *v2
		}
	}
	this.HallVersion = uint32(r.Uint32())
	this.AreaId = uint32(r.Uint32())
	this.IsNew = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatch(r, 14)
	}
	return this
}

func NewPopulatedListsResponse(r randyMatch, easy bool) *ListsResponse {
	this := &ListsResponse{}
	this.Tpage = uint64(uint64(r.Uint32()))
	this.Srvtime = uint64(uint64(r.Uint32()))
	if r.Intn(10) != 0 {
		v3 := r.Intn(10)
		this.List = make(map[uint32]List)
		for i := 0; i < v3; i++ {
			this.List[uint32(r.Uint32())] = *NewPopulatedList(r, easy)
		}
	}
	this.Filter = uint32(r.Uint32())
	this.Iconmax = uint32(r.Uint32())
	this.Pnum = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v4 := r.Intn(10)
		this.Apply = make([]uint64, v4)
		for i := 0; i < v4; i++ {
			this.Apply[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(10)
		this.Delete = make(map[uint32]List)
		for i := 0; i < v5; i++ {
			this.Delete[uint32(r.Uint32())] = *NewPopulatedList(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v6 := r.Intn(10)
		this.Update = make(map[uint32]List)
		for i := 0; i < v6; i++ {
			this.Update[uint32(r.Uint32())] = *NewPopulatedList(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(10)
		this.MatchIcons = make(map[string]MatchIcon)
		for i := 0; i < v7; i++ {
			this.MatchIcons[randStringMatch(r)] = *NewPopulatedMatchIcon(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v8 := r.Intn(10)
		this.Sort = make(map[string]uint32)
		for i := 0; i < v8; i++ {
			v9 := randStringMatch(r)
			this.Sort[v9] = uint32(r.Uint32())
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatch(r, 12)
	}
	return this
}

func NewPopulatedId(r randyMatch, easy bool) *Id {
	this := &Id{}
	this.Type = uint32(r.Uint32())
	this.Id = uint64(uint64(r.Uint32()))
	this.Configid = uint64(uint64(r.Uint32()))
	this.Applynum = uint64(uint64(r.Uint32()))
	this.Allapplynum = uint64(uint64(r.Uint32()))
	this.Stime = uint64(uint64(r.Uint32()))
	this.Etime = uint64(uint64(r.Uint32()))
	this.Status = uint32(r.Uint32())
	this.Matchpartitions = uint64(uint64(r.Uint32()))
	this.FreeTimes = uint32(r.Uint32())
	this.AllFreeTimes = uint32(r.Uint32())
	this.AllDiscountNum = uint32(r.Uint32())
	this.RemainDiscountNum = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v10 := r.Intn(5)
		this.Fee = make([]Fee, v10)
		for i := 0; i < v10; i++ {
			v11 := NewPopulatedFee(r, easy)
			this.Fee[i] = *v11
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatch(r, 15)
	}
	return this
}

func NewPopulatedMatchIcon(r randyMatch, easy bool) *MatchIcon {
	this := &MatchIcon{}
	this.Icon = string(randStringMatch(r))
	this.Color = string(randStringMatch(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatch(r, 3)
	}
	return this
}

func NewPopulatedList(r randyMatch, easy bool) *List {
	this := &List{}
	this.Id = uint64(uint64(r.Uint32()))
	this.Type = uint32(r.Uint32())
	this.Mname = string(randStringMatch(r))
	this.Micon = string(randStringMatch(r))
	this.Iconweight = string(randStringMatch(r))
	this.AdIcon = string(randStringMatch(r))
	this.ListSort = string(randStringMatch(r))
	this.Stime = uint64(uint64(r.Uint32()))
	this.Etime = uint64(uint64(r.Uint32()))
	this.Gameid = uint64(uint64(r.Uint32()))
	this.Gamesort = uint64(uint64(r.Uint32()))
	this.Requestnum = string(randStringMatch(r))
	this.Applynum = uint64(uint64(r.Uint32()))
	this.Allowwaittime = uint32(r.Uint32())
	this.Champion = string(randStringMatch(r))
	if r.Intn(10) != 0 {
		v12 := r.Intn(5)
		this.Fee = make([]Fee, v12)
		for i := 0; i < v12; i++ {
			v13 := NewPopulatedFee(r, easy)
			this.Fee[i] = *v13
		}
	}
	this.Status = uint32(r.Uint32())
	this.Looptype = uint32(r.Uint32())
	this.Loopinterval = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.Loopinterval *= -1
	}
	this.Loopendtime = string(randStringMatch(r))
	this.RewardUrl = string(randStringMatch(r))
	this.RewardDescribe = string(randStringMatch(r))
	this.ThresholdType = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.ThresholdType *= -1
	}
	this.Threshold = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Threshold *= -1
	}
	this.Configid = string(randStringMatch(r))
	this.Matchtags = string(randStringMatch(r))
	this.Matchentrycode = string(randStringMatch(r))
	this.Matchentryinfo = string(randStringMatch(r))
	this.Sname = string(randStringMatch(r))
	this.Gamename = string(randStringMatch(r))
	this.Advicon = string(randStringMatch(r))
	this.Maxawardpool = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v14 := r.Intn(10)
		this.Mclabel = make(map[string]string)
		for i := 0; i < v14; i++ {
			this.Mclabel[randStringMatch(r)] = randStringMatch(r)
		}
	}
	this.Allapplynum = uint64(uint64(r.Uint32()))
	this.AllFreeTimes = uint32(r.Uint32())
	this.FreeTimes = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v15 := r.Intn(10)
		this.Moneylimit = make(map[string]string)
		for i := 0; i < v15; i++ {
			this.Moneylimit[randStringMatch(r)] = randStringMatch(r)
		}
	}
	this.Recommendmatchcfgid = uint64(uint64(r.Uint32()))
	this.Endtime = uint64(uint64(r.Uint32()))
	this.Matchpartitions = uint64(uint64(r.Uint32()))
	this.Isfhmatch = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Isfhmatch *= -1
	}
	this.Loopintervaltime = uint64(uint64(r.Uint32()))
	this.Firstbegintime = uint64(uint64(r.Uint32()))
	this.DiscountPrice = uint64(uint64(r.Uint32()))
	this.DiscountType = uint32(r.Uint32())
	this.AllDiscountNum = uint32(r.Uint32())
	this.RemainDiscountNum = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatch(r, 48)
	}
	return this
}

func NewPopulatedFee(r randyMatch, easy bool) *Fee {
	this := &Fee{}
	if r.Intn(10) != 0 {
		v16 := r.Intn(5)
		this.Subfee = make([]SubFee, v16)
		for i := 0; i < v16; i++ {
			v17 := NewPopulatedSubFee(r, easy)
			this.Subfee[i] = *v17
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatch(r, 2)
	}
	return this
}

func NewPopulatedSubFee(r randyMatch, easy bool) *SubFee {
	this := &SubFee{}
	this.Type = uint32(r.Uint32())
	this.Num = uint64(uint64(r.Uint32()))
	this.Desc = string(randStringMatch(r))
	this.Label = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatch(r, 5)
	}
	return this
}

type randyMatch interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneMatch(r randyMatch) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringMatch(r randyMatch) string {
	v18 := r.Intn(100)
	tmps := make([]rune, v18)
	for i := 0; i < v18; i++ {
		tmps[i] = randUTF8RuneMatch(r)
	}
	return string(tmps)
}
func randUnrecognizedMatch(r randyMatch, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldMatch(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldMatch(dAtA []byte, r randyMatch, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateMatch(dAtA, uint64(key))
		v19 := r.Int63()
		if r.Intn(2) == 0 {
			v19 *= -1
		}
		dAtA = encodeVarintPopulateMatch(dAtA, uint64(v19))
	case 1:
		dAtA = encodeVarintPopulateMatch(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateMatch(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateMatch(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateMatch(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateMatch(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *ListsRequest) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMatch(uint64(m.Cmd))
	n += 1 + sovMatch(uint64(m.App))
	n += 1 + sovMatch(uint64(m.GameId))
	n += 1 + sovMatch(uint64(m.Mid))
	l = len(m.Ssid)
	n += 1 + l + sovMatch(uint64(l))
	l = len(m.Action)
	n += 1 + l + sovMatch(uint64(l))
	n += 1 + sovMatch(uint64(m.Page))
	n += 1 + sovMatch(uint64(m.Timestamp))
	n += 1 + sovMatch(uint64(m.Seq))
	if len(m.Ids) > 0 {
		for _, e := range m.Ids {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	n += 1 + sovMatch(uint64(m.HallVersion))
	n += 1 + sovMatch(uint64(m.AreaId))
	n += 1 + sovMatch(uint64(m.IsNew))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListsResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMatch(uint64(m.Tpage))
	n += 1 + sovMatch(uint64(m.Srvtime))
	if len(m.List) > 0 {
		for k, v := range m.List {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovMatch(uint64(k)) + 1 + l + sovMatch(uint64(l))
			n += mapEntrySize + 1 + sovMatch(uint64(mapEntrySize))
		}
	}
	n += 1 + sovMatch(uint64(m.Filter))
	n += 1 + sovMatch(uint64(m.Iconmax))
	n += 1 + sovMatch(uint64(m.Pnum))
	if len(m.Apply) > 0 {
		for _, e := range m.Apply {
			n += 1 + sovMatch(uint64(e))
		}
	}
	if len(m.Delete) > 0 {
		for k, v := range m.Delete {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovMatch(uint64(k)) + 1 + l + sovMatch(uint64(l))
			n += mapEntrySize + 1 + sovMatch(uint64(mapEntrySize))
		}
	}
	if len(m.Update) > 0 {
		for k, v := range m.Update {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovMatch(uint64(k)) + 1 + l + sovMatch(uint64(l))
			n += mapEntrySize + 1 + sovMatch(uint64(mapEntrySize))
		}
	}
	if len(m.MatchIcons) > 0 {
		for k, v := range m.MatchIcons {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovMatch(uint64(len(k))) + 1 + l + sovMatch(uint64(l))
			n += mapEntrySize + 1 + sovMatch(uint64(mapEntrySize))
		}
	}
	if len(m.Sort) > 0 {
		for k, v := range m.Sort {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMatch(uint64(len(k))) + 1 + sovMatch(uint64(v))
			n += mapEntrySize + 1 + sovMatch(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Id) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMatch(uint64(m.Type))
	n += 1 + sovMatch(uint64(m.Id))
	n += 1 + sovMatch(uint64(m.Configid))
	n += 1 + sovMatch(uint64(m.Applynum))
	n += 1 + sovMatch(uint64(m.Allapplynum))
	n += 1 + sovMatch(uint64(m.Stime))
	n += 1 + sovMatch(uint64(m.Etime))
	n += 1 + sovMatch(uint64(m.Status))
	n += 1 + sovMatch(uint64(m.Matchpartitions))
	n += 1 + sovMatch(uint64(m.FreeTimes))
	n += 1 + sovMatch(uint64(m.AllFreeTimes))
	n += 1 + sovMatch(uint64(m.AllDiscountNum))
	n += 1 + sovMatch(uint64(m.RemainDiscountNum))
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchIcon) Size() (n int) {
	var l int
	_ = l
	l = len(m.Icon)
	n += 1 + l + sovMatch(uint64(l))
	l = len(m.Color)
	n += 1 + l + sovMatch(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *List) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMatch(uint64(m.Id))
	n += 1 + sovMatch(uint64(m.Type))
	l = len(m.Mname)
	n += 1 + l + sovMatch(uint64(l))
	l = len(m.Micon)
	n += 1 + l + sovMatch(uint64(l))
	l = len(m.Iconweight)
	n += 1 + l + sovMatch(uint64(l))
	l = len(m.AdIcon)
	n += 1 + l + sovMatch(uint64(l))
	l = len(m.ListSort)
	n += 1 + l + sovMatch(uint64(l))
	n += 1 + sovMatch(uint64(m.Stime))
	n += 1 + sovMatch(uint64(m.Etime))
	n += 1 + sovMatch(uint64(m.Gameid))
	n += 1 + sovMatch(uint64(m.Gamesort))
	l = len(m.Requestnum)
	n += 1 + l + sovMatch(uint64(l))
	n += 1 + sovMatch(uint64(m.Applynum))
	n += 1 + sovMatch(uint64(m.Allowwaittime))
	l = len(m.Champion)
	n += 1 + l + sovMatch(uint64(l))
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 2 + l + sovMatch(uint64(l))
		}
	}
	n += 2 + sovMatch(uint64(m.Status))
	n += 2 + sovMatch(uint64(m.Looptype))
	n += 6
	l = len(m.Loopendtime)
	n += 2 + l + sovMatch(uint64(l))
	l = len(m.RewardUrl)
	n += 2 + l + sovMatch(uint64(l))
	l = len(m.RewardDescribe)
	n += 2 + l + sovMatch(uint64(l))
	n += 10
	n += 10
	l = len(m.Configid)
	n += 2 + l + sovMatch(uint64(l))
	l = len(m.Matchtags)
	n += 2 + l + sovMatch(uint64(l))
	l = len(m.Matchentrycode)
	n += 2 + l + sovMatch(uint64(l))
	l = len(m.Matchentryinfo)
	n += 2 + l + sovMatch(uint64(l))
	l = len(m.Sname)
	n += 2 + l + sovMatch(uint64(l))
	l = len(m.Gamename)
	n += 2 + l + sovMatch(uint64(l))
	l = len(m.Advicon)
	n += 2 + l + sovMatch(uint64(l))
	n += 2 + sovMatch(uint64(m.Maxawardpool))
	if len(m.Mclabel) > 0 {
		for k, v := range m.Mclabel {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMatch(uint64(len(k))) + 1 + len(v) + sovMatch(uint64(len(v)))
			n += mapEntrySize + 2 + sovMatch(uint64(mapEntrySize))
		}
	}
	n += 2 + sovMatch(uint64(m.Allapplynum))
	n += 2 + sovMatch(uint64(m.AllFreeTimes))
	n += 2 + sovMatch(uint64(m.FreeTimes))
	if len(m.Moneylimit) > 0 {
		for k, v := range m.Moneylimit {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMatch(uint64(len(k))) + 1 + len(v) + sovMatch(uint64(len(v)))
			n += mapEntrySize + 2 + sovMatch(uint64(mapEntrySize))
		}
	}
	n += 2 + sovMatch(uint64(m.Recommendmatchcfgid))
	n += 2 + sovMatch(uint64(m.Endtime))
	n += 2 + sovMatch(uint64(m.Matchpartitions))
	n += 10
	n += 2 + sovMatch(uint64(m.Loopintervaltime))
	n += 2 + sovMatch(uint64(m.Firstbegintime))
	n += 2 + sovMatch(uint64(m.DiscountPrice))
	n += 2 + sovMatch(uint64(m.DiscountType))
	n += 2 + sovMatch(uint64(m.AllDiscountNum))
	n += 2 + sovMatch(uint64(m.RemainDiscountNum))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Fee) Size() (n int) {
	var l int
	_ = l
	if len(m.Subfee) > 0 {
		for _, e := range m.Subfee {
			l = e.Size()
			n += 1 + l + sovMatch(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubFee) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMatch(uint64(m.Type))
	n += 1 + sovMatch(uint64(m.Num))
	l = len(m.Desc)
	n += 1 + l + sovMatch(uint64(l))
	n += 1 + sovMatch(uint64(m.Label))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMatch(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMatch(x uint64) (n int) {
	return sovMatch(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ListsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ListsRequest{`,
		`Cmd:` + fmt.Sprintf("%v", this.Cmd) + `,`,
		`App:` + fmt.Sprintf("%v", this.App) + `,`,
		`GameId:` + fmt.Sprintf("%v", this.GameId) + `,`,
		`Mid:` + fmt.Sprintf("%v", this.Mid) + `,`,
		`Ssid:` + fmt.Sprintf("%v", this.Ssid) + `,`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`Page:` + fmt.Sprintf("%v", this.Page) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`Ids:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Ids), "List", "List", 1), `&`, ``, 1) + `,`,
		`HallVersion:` + fmt.Sprintf("%v", this.HallVersion) + `,`,
		`AreaId:` + fmt.Sprintf("%v", this.AreaId) + `,`,
		`IsNew:` + fmt.Sprintf("%v", this.IsNew) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ListsResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForList := make([]uint32, 0, len(this.List))
	for k, _ := range this.List {
		keysForList = append(keysForList, k)
	}
	sortkeys.Uint32s(keysForList)
	mapStringForList := "map[uint32]List{"
	for _, k := range keysForList {
		mapStringForList += fmt.Sprintf("%v: %v,", k, this.List[k])
	}
	mapStringForList += "}"
	keysForDelete := make([]uint32, 0, len(this.Delete))
	for k, _ := range this.Delete {
		keysForDelete = append(keysForDelete, k)
	}
	sortkeys.Uint32s(keysForDelete)
	mapStringForDelete := "map[uint32]List{"
	for _, k := range keysForDelete {
		mapStringForDelete += fmt.Sprintf("%v: %v,", k, this.Delete[k])
	}
	mapStringForDelete += "}"
	keysForUpdate := make([]uint32, 0, len(this.Update))
	for k, _ := range this.Update {
		keysForUpdate = append(keysForUpdate, k)
	}
	sortkeys.Uint32s(keysForUpdate)
	mapStringForUpdate := "map[uint32]List{"
	for _, k := range keysForUpdate {
		mapStringForUpdate += fmt.Sprintf("%v: %v,", k, this.Update[k])
	}
	mapStringForUpdate += "}"
	keysForMatchIcons := make([]string, 0, len(this.MatchIcons))
	for k, _ := range this.MatchIcons {
		keysForMatchIcons = append(keysForMatchIcons, k)
	}
	sortkeys.Strings(keysForMatchIcons)
	mapStringForMatchIcons := "map[string]MatchIcon{"
	for _, k := range keysForMatchIcons {
		mapStringForMatchIcons += fmt.Sprintf("%v: %v,", k, this.MatchIcons[k])
	}
	mapStringForMatchIcons += "}"
	keysForSort := make([]string, 0, len(this.Sort))
	for k, _ := range this.Sort {
		keysForSort = append(keysForSort, k)
	}
	sortkeys.Strings(keysForSort)
	mapStringForSort := "map[string]uint32{"
	for _, k := range keysForSort {
		mapStringForSort += fmt.Sprintf("%v: %v,", k, this.Sort[k])
	}
	mapStringForSort += "}"
	s := strings.Join([]string{`&ListsResponse{`,
		`Tpage:` + fmt.Sprintf("%v", this.Tpage) + `,`,
		`Srvtime:` + fmt.Sprintf("%v", this.Srvtime) + `,`,
		`List:` + mapStringForList + `,`,
		`Filter:` + fmt.Sprintf("%v", this.Filter) + `,`,
		`Iconmax:` + fmt.Sprintf("%v", this.Iconmax) + `,`,
		`Pnum:` + fmt.Sprintf("%v", this.Pnum) + `,`,
		`Apply:` + fmt.Sprintf("%v", this.Apply) + `,`,
		`Delete:` + mapStringForDelete + `,`,
		`Update:` + mapStringForUpdate + `,`,
		`MatchIcons:` + mapStringForMatchIcons + `,`,
		`Sort:` + mapStringForSort + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Id) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Id{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Configid:` + fmt.Sprintf("%v", this.Configid) + `,`,
		`Applynum:` + fmt.Sprintf("%v", this.Applynum) + `,`,
		`Allapplynum:` + fmt.Sprintf("%v", this.Allapplynum) + `,`,
		`Stime:` + fmt.Sprintf("%v", this.Stime) + `,`,
		`Etime:` + fmt.Sprintf("%v", this.Etime) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Matchpartitions:` + fmt.Sprintf("%v", this.Matchpartitions) + `,`,
		`FreeTimes:` + fmt.Sprintf("%v", this.FreeTimes) + `,`,
		`AllFreeTimes:` + fmt.Sprintf("%v", this.AllFreeTimes) + `,`,
		`AllDiscountNum:` + fmt.Sprintf("%v", this.AllDiscountNum) + `,`,
		`RemainDiscountNum:` + fmt.Sprintf("%v", this.RemainDiscountNum) + `,`,
		`Fee:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Fee), "Fee", "Fee", 1), `&`, ``, 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchIcon) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchIcon{`,
		`Icon:` + fmt.Sprintf("%v", this.Icon) + `,`,
		`Color:` + fmt.Sprintf("%v", this.Color) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *List) String() string {
	if this == nil {
		return "nil"
	}
	keysForMclabel := make([]string, 0, len(this.Mclabel))
	for k, _ := range this.Mclabel {
		keysForMclabel = append(keysForMclabel, k)
	}
	sortkeys.Strings(keysForMclabel)
	mapStringForMclabel := "map[string]string{"
	for _, k := range keysForMclabel {
		mapStringForMclabel += fmt.Sprintf("%v: %v,", k, this.Mclabel[k])
	}
	mapStringForMclabel += "}"
	keysForMoneylimit := make([]string, 0, len(this.Moneylimit))
	for k, _ := range this.Moneylimit {
		keysForMoneylimit = append(keysForMoneylimit, k)
	}
	sortkeys.Strings(keysForMoneylimit)
	mapStringForMoneylimit := "map[string]string{"
	for _, k := range keysForMoneylimit {
		mapStringForMoneylimit += fmt.Sprintf("%v: %v,", k, this.Moneylimit[k])
	}
	mapStringForMoneylimit += "}"
	s := strings.Join([]string{`&List{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Mname:` + fmt.Sprintf("%v", this.Mname) + `,`,
		`Micon:` + fmt.Sprintf("%v", this.Micon) + `,`,
		`Iconweight:` + fmt.Sprintf("%v", this.Iconweight) + `,`,
		`AdIcon:` + fmt.Sprintf("%v", this.AdIcon) + `,`,
		`ListSort:` + fmt.Sprintf("%v", this.ListSort) + `,`,
		`Stime:` + fmt.Sprintf("%v", this.Stime) + `,`,
		`Etime:` + fmt.Sprintf("%v", this.Etime) + `,`,
		`Gameid:` + fmt.Sprintf("%v", this.Gameid) + `,`,
		`Gamesort:` + fmt.Sprintf("%v", this.Gamesort) + `,`,
		`Requestnum:` + fmt.Sprintf("%v", this.Requestnum) + `,`,
		`Applynum:` + fmt.Sprintf("%v", this.Applynum) + `,`,
		`Allowwaittime:` + fmt.Sprintf("%v", this.Allowwaittime) + `,`,
		`Champion:` + fmt.Sprintf("%v", this.Champion) + `,`,
		`Fee:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Fee), "Fee", "Fee", 1), `&`, ``, 1) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Looptype:` + fmt.Sprintf("%v", this.Looptype) + `,`,
		`Loopinterval:` + fmt.Sprintf("%v", this.Loopinterval) + `,`,
		`Loopendtime:` + fmt.Sprintf("%v", this.Loopendtime) + `,`,
		`RewardUrl:` + fmt.Sprintf("%v", this.RewardUrl) + `,`,
		`RewardDescribe:` + fmt.Sprintf("%v", this.RewardDescribe) + `,`,
		`ThresholdType:` + fmt.Sprintf("%v", this.ThresholdType) + `,`,
		`Threshold:` + fmt.Sprintf("%v", this.Threshold) + `,`,
		`Configid:` + fmt.Sprintf("%v", this.Configid) + `,`,
		`Matchtags:` + fmt.Sprintf("%v", this.Matchtags) + `,`,
		`Matchentrycode:` + fmt.Sprintf("%v", this.Matchentrycode) + `,`,
		`Matchentryinfo:` + fmt.Sprintf("%v", this.Matchentryinfo) + `,`,
		`Sname:` + fmt.Sprintf("%v", this.Sname) + `,`,
		`Gamename:` + fmt.Sprintf("%v", this.Gamename) + `,`,
		`Advicon:` + fmt.Sprintf("%v", this.Advicon) + `,`,
		`Maxawardpool:` + fmt.Sprintf("%v", this.Maxawardpool) + `,`,
		`Mclabel:` + mapStringForMclabel + `,`,
		`Allapplynum:` + fmt.Sprintf("%v", this.Allapplynum) + `,`,
		`AllFreeTimes:` + fmt.Sprintf("%v", this.AllFreeTimes) + `,`,
		`FreeTimes:` + fmt.Sprintf("%v", this.FreeTimes) + `,`,
		`Moneylimit:` + mapStringForMoneylimit + `,`,
		`Recommendmatchcfgid:` + fmt.Sprintf("%v", this.Recommendmatchcfgid) + `,`,
		`Endtime:` + fmt.Sprintf("%v", this.Endtime) + `,`,
		`Matchpartitions:` + fmt.Sprintf("%v", this.Matchpartitions) + `,`,
		`Isfhmatch:` + fmt.Sprintf("%v", this.Isfhmatch) + `,`,
		`Loopintervaltime:` + fmt.Sprintf("%v", this.Loopintervaltime) + `,`,
		`Firstbegintime:` + fmt.Sprintf("%v", this.Firstbegintime) + `,`,
		`DiscountPrice:` + fmt.Sprintf("%v", this.DiscountPrice) + `,`,
		`DiscountType:` + fmt.Sprintf("%v", this.DiscountType) + `,`,
		`AllDiscountNum:` + fmt.Sprintf("%v", this.AllDiscountNum) + `,`,
		`RemainDiscountNum:` + fmt.Sprintf("%v", this.RemainDiscountNum) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Fee) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Fee{`,
		`Subfee:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Subfee), "SubFee", "SubFee", 1), `&`, ``, 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubFee) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubFee{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Num:` + fmt.Sprintf("%v", this.Num) + `,`,
		`Desc:` + fmt.Sprintf("%v", this.Desc) + `,`,
		`Label:` + fmt.Sprintf("%v", this.Label) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMatch(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ListsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			m.App = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.App |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ssid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ssid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, List{})
			if err := m.Ids[len(m.Ids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HallVersion", wireType)
			}
			m.HallVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HallVersion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaId", wireType)
			}
			m.AreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNew", wireType)
			}
			m.IsNew = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsNew |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tpage", wireType)
			}
			m.Tpage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tpage |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Srvtime", wireType)
			}
			m.Srvtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Srvtime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.List == nil {
				m.List = make(map[uint32]List)
			}
			var mapkey uint32
			mapvalue := &List{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMatch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMatch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &List{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMatch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMatch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.List[mapkey] = *mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			m.Filter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Filter |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iconmax", wireType)
			}
			m.Iconmax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iconmax |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pnum", wireType)
			}
			m.Pnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pnum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Apply = append(m.Apply, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMatch
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Apply = append(m.Apply, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Apply", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Delete == nil {
				m.Delete = make(map[uint32]List)
			}
			var mapkey uint32
			mapvalue := &List{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMatch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMatch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &List{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMatch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMatch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Delete[mapkey] = *mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Update == nil {
				m.Update = make(map[uint32]List)
			}
			var mapkey uint32
			mapvalue := &List{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMatch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMatch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &List{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMatch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMatch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Update[mapkey] = *mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchIcons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchIcons == nil {
				m.MatchIcons = make(map[string]MatchIcon)
			}
			var mapkey string
			mapvalue := &MatchIcon{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMatch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMatch
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMatch
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MatchIcon{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMatch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMatch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MatchIcons[mapkey] = *mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sort == nil {
				m.Sort = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMatch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMatch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMatch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sort[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Id) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Id: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Id: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configid", wireType)
			}
			m.Configid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Configid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applynum", wireType)
			}
			m.Applynum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Applynum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allapplynum", wireType)
			}
			m.Allapplynum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Allapplynum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stime", wireType)
			}
			m.Stime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etime", wireType)
			}
			m.Etime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Etime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matchpartitions", wireType)
			}
			m.Matchpartitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Matchpartitions |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeTimes", wireType)
			}
			m.FreeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeTimes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllFreeTimes", wireType)
			}
			m.AllFreeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllFreeTimes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllDiscountNum", wireType)
			}
			m.AllDiscountNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllDiscountNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainDiscountNum", wireType)
			}
			m.RemainDiscountNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainDiscountNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, Fee{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchIcon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchIcon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchIcon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Color = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Micon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Micon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iconweight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iconweight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListSort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ListSort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stime", wireType)
			}
			m.Stime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etime", wireType)
			}
			m.Etime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Etime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gameid", wireType)
			}
			m.Gameid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gameid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gamesort", wireType)
			}
			m.Gamesort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gamesort |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requestnum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requestnum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applynum", wireType)
			}
			m.Applynum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Applynum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allowwaittime", wireType)
			}
			m.Allowwaittime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Allowwaittime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Champion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Champion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, Fee{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Looptype", wireType)
			}
			m.Looptype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Looptype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loopinterval", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Loopinterval = float32(math.Float32frombits(v))
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loopendtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Loopendtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardDescribe", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardDescribe = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdType", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ThresholdType = float64(math.Float64frombits(v))
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Threshold = float64(math.Float64frombits(v))
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Configid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matchtags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Matchtags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matchentrycode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Matchentrycode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matchentryinfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Matchentryinfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gamename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gamename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Advicon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Advicon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maxawardpool", wireType)
			}
			m.Maxawardpool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Maxawardpool |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mclabel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mclabel == nil {
				m.Mclabel = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMatch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMatch
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMatch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMatch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Mclabel[mapkey] = mapvalue
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allapplynum", wireType)
			}
			m.Allapplynum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Allapplynum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllFreeTimes", wireType)
			}
			m.AllFreeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllFreeTimes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeTimes", wireType)
			}
			m.FreeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeTimes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moneylimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Moneylimit == nil {
				m.Moneylimit = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatch
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMatch
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatch
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMatch
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMatch(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMatch
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Moneylimit[mapkey] = mapvalue
			iNdEx = postIndex
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recommendmatchcfgid", wireType)
			}
			m.Recommendmatchcfgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Recommendmatchcfgid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endtime", wireType)
			}
			m.Endtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Endtime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matchpartitions", wireType)
			}
			m.Matchpartitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Matchpartitions |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isfhmatch", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Isfhmatch = float64(math.Float64frombits(v))
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loopintervaltime", wireType)
			}
			m.Loopintervaltime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Loopintervaltime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Firstbegintime", wireType)
			}
			m.Firstbegintime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Firstbegintime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountPrice", wireType)
			}
			m.DiscountPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscountPrice |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiscountType", wireType)
			}
			m.DiscountType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiscountType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllDiscountNum", wireType)
			}
			m.AllDiscountNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllDiscountNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainDiscountNum", wireType)
			}
			m.RemainDiscountNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainDiscountNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subfee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subfee = append(m.Subfee, SubFee{})
			if err := m.Subfee[len(m.Subfee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatch
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			m.Label = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Label |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatch(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatch
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMatch(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMatch
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMatch
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMatch
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMatch
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMatch(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMatch = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMatch   = fmt.Errorf("proto: integer overflow")
)

func init() { proto1.RegisterFile("match.proto", fileDescriptorMatch) }

var fileDescriptorMatch = []byte{
	// 1483 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0xcf, 0x6e, 0xdb, 0xc6,
	0x13, 0x0e, 0x2d, 0x59, 0x8e, 0x56, 0x56, 0xec, 0x6c, 0xfc, 0xcb, 0x6f, 0xeb, 0x24, 0x8c, 0xa2,
	0xa4, 0x89, 0x9a, 0x3f, 0x4a, 0x90, 0x43, 0x1b, 0x04, 0x68, 0x01, 0x07, 0x8e, 0x01, 0xa3, 0x4d,
	0x5a, 0xd8, 0x49, 0xaf, 0xc1, 0x8a, 0x5c, 0x49, 0x8b, 0xf2, 0x5f, 0xb8, 0x94, 0x1d, 0xdf, 0xfa,
	0x00, 0x3d, 0x17, 0x7d, 0x84, 0x3e, 0x42, 0x8f, 0x3d, 0xe6, 0xd8, 0x63, 0xd1, 0x43, 0x11, 0xab,
	0x2f, 0xd0, 0x63, 0xd1, 0x53, 0x31, 0x43, 0x2e, 0x35, 0x94, 0x0c, 0x17, 0x6d, 0x4f, 0x16, 0xbf,
	0x6f, 0x66, 0xb8, 0x3b, 0xf3, 0xcd, 0x0c, 0xcd, 0x5a, 0xa1, 0xcc, 0xbc, 0x71, 0x3f, 0x49, 0xe3,
	0x2c, 0xe6, 0xcb, 0xf8, 0x67, 0xf3, 0xde, 0x48, 0x67, 0xe3, 0xc9, 0xa0, 0xef, 0xc5, 0xe1, 0xfd,
	0x51, 0x3c, 0x8a, 0xef, 0x23, 0x3c, 0x98, 0x0c, 0xf1, 0x09, 0x1f, 0xf0, 0x57, 0xee, 0xd5, 0xfd,
	0xa6, 0xc6, 0x56, 0x3f, 0xd3, 0x26, 0x33, 0x7b, 0xea, 0xf5, 0x44, 0x99, 0x8c, 0x5f, 0x64, 0x35,
	0x2f, 0xf4, 0x85, 0xd3, 0x71, 0x7a, 0xf5, 0x27, 0xf5, 0xb7, 0xbf, 0x5e, 0x3d, 0xb3, 0x07, 0x00,
	0xe0, 0x32, 0x49, 0xc4, 0x12, 0xc5, 0x65, 0x92, 0xf0, 0x2b, 0x6c, 0x65, 0x24, 0x43, 0xf5, 0x4a,
	0xfb, 0xa2, 0x46, 0xb8, 0x06, 0x80, 0xbb, 0xe8, 0x16, 0x6a, 0x5f, 0xd4, 0xa9, 0x5b, 0xa8, 0x7d,
	0x2e, 0x58, 0xdd, 0x18, 0xed, 0x8b, 0xe5, 0x8e, 0xd3, 0x6b, 0x16, 0x04, 0x22, 0xfc, 0x32, 0x6b,
	0x48, 0x2f, 0xd3, 0x71, 0x24, 0x1a, 0x84, 0x2b, 0x30, 0xf0, 0x4b, 0xe4, 0x48, 0x89, 0x95, 0x8e,
	0xd3, 0x6b, 0x5b, 0x3f, 0x40, 0x78, 0x97, 0x35, 0x33, 0x1d, 0x2a, 0x93, 0xc9, 0x30, 0x11, 0x67,
	0xc9, 0xfb, 0x66, 0x30, 0x9c, 0xc6, 0xa8, 0xd7, 0xa2, 0x49, 0x9c, 0x01, 0xe0, 0xd7, 0x59, 0x4d,
	0xfb, 0x46, 0xb0, 0x4e, 0xad, 0xd7, 0x7a, 0xd8, 0xca, 0x53, 0xd3, 0x87, 0xb4, 0x58, 0x23, 0xed,
	0x1b, 0x7e, 0x8b, 0xad, 0x8e, 0x65, 0x10, 0xbc, 0x3a, 0x50, 0xa9, 0x81, 0xe3, 0xb5, 0x48, 0x94,
	0x16, 0x30, 0x5f, 0xe6, 0x04, 0xa4, 0x44, 0xa6, 0x4a, 0x42, 0x4a, 0x56, 0x89, 0x4d, 0x03, 0xc0,
	0x5d, 0x9f, 0x6f, 0xb2, 0x65, 0x6d, 0x9e, 0xab, 0x43, 0xd1, 0x26, 0x64, 0x0e, 0x75, 0x7f, 0x69,
	0xb0, 0x76, 0x51, 0x0e, 0x93, 0xc4, 0x91, 0x51, 0x60, 0x9d, 0xe1, 0x8d, 0x69, 0x45, 0x72, 0x88,
	0xbb, 0x6c, 0xc5, 0xa4, 0x07, 0x70, 0xbd, 0x4a, 0x5d, 0x2c, 0xc8, 0x1f, 0xb1, 0x7a, 0xa0, 0x4d,
	0x26, 0x6a, 0x78, 0x2f, 0x97, 0xdc, 0xab, 0x8c, 0x8f, 0x4f, 0x4f, 0xa3, 0x2c, 0x3d, 0xb2, 0xc9,
	0x04, 0x0f, 0x28, 0xc2, 0x50, 0x07, 0x99, 0x4a, 0xb1, 0x72, 0xe5, 0x0d, 0x72, 0x0c, 0xde, 0xab,
	0xbd, 0x38, 0x0a, 0xe5, 0x1b, 0xac, 0x9f, 0xa5, 0x2d, 0x88, 0x45, 0x8a, 0x26, 0x21, 0x16, 0x70,
	0x56, 0xa4, 0x68, 0x12, 0xf2, 0x0d, 0xb6, 0x2c, 0x93, 0x24, 0x38, 0x12, 0x2b, 0x9d, 0x5a, 0xaf,
	0xbe, 0x97, 0x3f, 0xf0, 0x4f, 0x58, 0xc3, 0x57, 0x81, 0xca, 0x94, 0x38, 0x8b, 0x27, 0xed, 0x9c,
	0x78, 0xd2, 0x6d, 0x34, 0xa1, 0x67, 0x2d, 0xbc, 0xc0, 0x7f, 0x92, 0xf8, 0x32, 0x53, 0xa2, 0x79,
	0x8a, 0xff, 0x4b, 0x34, 0xa9, 0xf8, 0xe7, 0x5e, 0xfc, 0xd3, 0xa2, 0x93, 0x5e, 0xc1, 0x05, 0xac,
	0x0c, 0x6e, 0x9c, 0x18, 0xe4, 0x19, 0xd8, 0xed, 0x82, 0x19, 0x0d, 0xc4, 0xc2, 0x12, 0x86, 0xa4,
	0x9b, 0x38, 0xcd, 0x44, 0xeb, 0x94, 0xa4, 0xef, 0xc7, 0x69, 0x35, 0xe9, 0xe0, 0xb1, 0xb9, 0xcd,
	0x9a, 0x65, 0x35, 0xf8, 0x3a, 0xab, 0x7d, 0xa5, 0x8e, 0xb0, 0xea, 0xed, 0x3d, 0xf8, 0xc9, 0xaf,
	0xb1, 0xe5, 0x03, 0x19, 0x4c, 0xf2, 0x5a, 0x57, 0x65, 0xba, 0x97, 0x33, 0x8f, 0x97, 0x1e, 0x39,
	0x9b, 0x3b, 0xac, 0x45, 0x32, 0xf5, 0x9f, 0xe2, 0x90, 0x8c, 0xfd, 0xfb, 0x38, 0x9f, 0xb3, 0xb5,
	0xb9, 0xa4, 0xd1, 0x58, 0xcd, 0x3c, 0xd6, 0xcd, 0x6a, 0xac, 0xf5, 0x22, 0x56, 0xe9, 0x48, 0x03,
	0x7e, 0xc4, 0x9a, 0x65, 0xfe, 0x4e, 0x08, 0xb5, 0x41, 0x43, 0xb5, 0x89, 0x63, 0xf7, 0xcf, 0x1a,
	0x5b, 0xda, 0xc5, 0xd1, 0x93, 0x1d, 0x25, 0x79, 0x43, 0x95, 0xea, 0x04, 0x84, 0x6f, 0xb0, 0x25,
	0xed, 0x57, 0x5a, 0x69, 0x49, 0xfb, 0xbc, 0xc3, 0xce, 0x7a, 0x71, 0x34, 0xd4, 0xa3, 0xb9, 0x11,
	0x57, 0xa2, 0x60, 0xb1, 0x05, 0x42, 0x06, 0xcd, 0xd3, 0x49, 0x57, 0xa2, 0xfc, 0x26, 0x6b, 0x6d,
	0x05, 0x81, 0xb4, 0x46, 0xcb, 0xc4, 0x88, 0x12, 0xd0, 0xed, 0xfb, 0xd8, 0xcf, 0x0d, 0xda, 0xed,
	0x08, 0x01, 0xf7, 0x14, 0xb9, 0x15, 0xca, 0x21, 0x04, 0xfd, 0xba, 0x9f, 0xc9, 0x6c, 0x62, 0x70,
	0xf2, 0x95, 0xfd, 0x9a, 0x63, 0xbc, 0x5f, 0x94, 0x20, 0x91, 0x69, 0xa6, 0x61, 0x8c, 0x1a, 0x1c,
	0x81, 0x36, 0xc6, 0x3c, 0x09, 0xa3, 0x74, 0x27, 0x55, 0xea, 0x05, 0xcc, 0x4d, 0xc1, 0x48, 0xc0,
	0x19, 0xcc, 0x7b, 0x6c, 0x75, 0x2b, 0x08, 0x66, 0x66, 0x74, 0x1a, 0x56, 0x18, 0x7e, 0x97, 0x9d,
	0xdb, 0x0a, 0x82, 0x6d, 0x6d, 0xbc, 0x78, 0x12, 0x65, 0xcf, 0x27, 0x61, 0x65, 0x2a, 0xce, 0x71,
	0xfc, 0x21, 0x3b, 0xbf, 0xa7, 0x42, 0xa9, 0x23, 0xea, 0x40, 0x27, 0xe5, 0x22, 0xcd, 0xbb, 0xac,
	0x36, 0x54, 0x4a, 0x9c, 0xc3, 0x8e, 0x63, 0x85, 0x76, 0x76, 0x94, 0xb2, 0xd3, 0x7b, 0xa8, 0x54,
	0x77, 0x8b, 0x35, 0x4b, 0x35, 0x81, 0x04, 0xa0, 0xd5, 0x73, 0xd9, 0x58, 0x09, 0x00, 0x02, 0x49,
	0xf6, 0xe2, 0x20, 0x4e, 0x51, 0x05, 0x96, 0xca, 0xa1, 0xee, 0xb7, 0x6b, 0xac, 0x0e, 0xea, 0x2e,
	0x74, 0xe2, 0xcc, 0xe9, 0xc4, 0xea, 0x6a, 0x69, 0x41, 0x57, 0x9b, 0x6c, 0x39, 0x8c, 0x64, 0xa8,
	0x50, 0x3e, 0x65, 0x50, 0x84, 0x90, 0xc3, 0xb3, 0xd4, 0x2b, 0x1c, 0x1e, 0xe6, 0x06, 0x63, 0xf0,
	0xf7, 0x50, 0xe9, 0xd1, 0x38, 0xab, 0xac, 0x4a, 0x82, 0xe3, 0xc2, 0xf4, 0xe1, 0x5a, 0x73, 0x0b,
	0x13, 0x31, 0xd0, 0x26, 0x4c, 0x74, 0xe8, 0x18, 0x14, 0x8e, 0xe5, 0x4b, 0x14, 0x4e, 0x60, 0x50,
	0x57, 0x74, 0x69, 0xe6, 0x10, 0x70, 0x0a, 0x39, 0xaa, 0x97, 0x1c, 0x82, 0xf7, 0xc2, 0x92, 0xd7,
	0x3e, 0x4a, 0xa4, 0xb2, 0xf8, 0xf3, 0x9e, 0x80, 0x5f, 0xc5, 0x28, 0x24, 0x3d, 0x61, 0x51, 0xb8,
	0x5d, 0x9a, 0x7f, 0x74, 0x44, 0x85, 0x26, 0xca, 0xdb, 0xcd, 0x70, 0x88, 0x53, 0xb6, 0x4d, 0x9b,
	0xc6, 0x29, 0x7b, 0xe6, 0x36, 0x6b, 0xcb, 0x20, 0x88, 0x0f, 0x0f, 0xa5, 0xce, 0xf0, 0xac, 0xe7,
	0x48, 0x01, 0xaa, 0x14, 0xf6, 0xf2, 0x58, 0x86, 0x09, 0xec, 0xef, 0x35, 0x9a, 0x0d, 0x8b, 0x5a,
	0x2d, 0xad, 0x9f, 0xa2, 0x25, 0xb8, 0xb9, 0xc9, 0xbb, 0xed, 0x3c, 0xed, 0xb6, 0x1c, 0xc3, 0x8c,
	0xc7, 0x71, 0x82, 0x5a, 0xe0, 0x84, 0x2f, 0x51, 0xe8, 0x1d, 0xf8, 0xad, 0xa3, 0x4c, 0xa5, 0x07,
	0x32, 0x10, 0x17, 0x3a, 0x4e, 0x6f, 0xc9, 0xf6, 0x0e, 0x65, 0x60, 0x6e, 0xc0, 0xb3, 0x8a, 0x7c,
	0xbc, 0xd9, 0x06, 0x39, 0x32, 0x25, 0xa0, 0x63, 0x53, 0x75, 0x28, 0x53, 0xff, 0x65, 0x1a, 0x88,
	0xff, 0x11, 0xab, 0x19, 0x0c, 0x7d, 0x98, 0x3f, 0x6c, 0x2b, 0xe3, 0xa5, 0x7a, 0xa0, 0xc4, 0x45,
	0x62, 0x38, 0xc7, 0x41, 0x56, 0xb3, 0x71, 0xaa, 0xcc, 0x38, 0x0e, 0xfc, 0x17, 0x70, 0x95, 0xff,
	0x77, 0x9c, 0x9e, 0x63, 0xb3, 0x5a, 0xa1, 0xf0, 0xd3, 0xcb, 0x02, 0x42, 0x10, 0xbb, 0x19, 0x5c,
	0x99, 0xa2, 0xef, 0x55, 0x32, 0x6f, 0xa7, 0x68, 0x97, 0x35, 0x71, 0x8d, 0x66, 0x72, 0x64, 0xc4,
	0x26, 0xbd, 0x43, 0x09, 0xc3, 0x1d, 0xf0, 0x41, 0xc1, 0xf0, 0xf7, 0x62, 0x5f, 0x89, 0x4b, 0xf4,
	0x0e, 0x55, 0xae, 0x6a, 0xad, 0xa3, 0x61, 0x2c, 0x2e, 0x9f, 0x6c, 0x0d, 0x1c, 0xf6, 0x01, 0x76,
	0xe9, 0x15, 0xda, 0x89, 0x08, 0x59, 0x35, 0x23, 0xed, 0xd2, 0xd3, 0x5b, 0x14, 0xbe, 0x89, 0xa4,
	0x7f, 0x80, 0x9d, 0x7c, 0x95, 0x18, 0x58, 0x10, 0x6a, 0x1e, 0xca, 0x37, 0x12, 0x72, 0x9c, 0xc4,
	0x71, 0x20, 0x3a, 0x74, 0x5e, 0x52, 0x86, 0x3f, 0x62, 0x2b, 0xa1, 0x17, 0xc8, 0x81, 0x0a, 0xc4,
	0x35, 0x54, 0xa1, 0x20, 0x9b, 0xb5, 0xff, 0x2c, 0xa7, 0xe8, 0xd7, 0x83, 0x35, 0x07, 0xb5, 0x48,
	0xb2, 0x65, 0xba, 0x74, 0xcb, 0x10, 0x02, 0xce, 0x22, 0xe9, 0xec, 0xbe, 0x4e, 0xcf, 0x42, 0x19,
	0xa8, 0xc9, 0xb0, 0x34, 0xbb, 0x41, 0x37, 0x41, 0x09, 0xf3, 0x2d, 0xc6, 0xc2, 0x38, 0x52, 0x47,
	0x81, 0x0e, 0x75, 0x26, 0xde, 0xc7, 0x23, 0x5f, 0xaa, 0x1c, 0xb9, 0x64, 0xab, 0xdf, 0x4c, 0x25,
	0xcc, 0x3f, 0x64, 0x17, 0x52, 0xe5, 0xc5, 0x61, 0xa8, 0x22, 0x1f, 0xab, 0xe2, 0x0d, 0x41, 0x27,
	0x37, 0xc9, 0x05, 0x4e, 0x32, 0x80, 0xa4, 0xdb, 0xd6, 0xb8, 0x45, 0x3f, 0x80, 0x6d, 0x5b, 0xf4,
	0xd9, 0x5a, 0x38, 0xb7, 0xf8, 0x7a, 0x74, 0xf1, 0x85, 0x8b, 0x8b, 0x4f, 0x9b, 0xe1, 0x18, 0x61,
	0xf1, 0x01, 0x15, 0x72, 0x09, 0xf3, 0x07, 0x6c, 0x9d, 0xb6, 0x28, 0xbe, 0xfc, 0x36, 0x09, 0xba,
	0xc0, 0x82, 0x0c, 0x87, 0x3a, 0x35, 0xd9, 0x40, 0x8d, 0x74, 0x84, 0xf6, 0x77, 0x88, 0xfd, 0x1c,
	0x07, 0x8d, 0xe7, 0x17, 0xbb, 0xed, 0x8b, 0x54, 0x7b, 0x4a, 0xdc, 0x25, 0xc6, 0x55, 0x0a, 0x0a,
	0x69, 0x01, 0xec, 0xd1, 0x7b, 0xb4, 0x90, 0x94, 0x81, 0x33, 0xc8, 0xea, 0x12, 0xee, 0xd3, 0x25,
	0x2c, 0x17, 0x96, 0x70, 0xba, 0xb0, 0x84, 0xef, 0xd3, 0x25, 0xbc, 0x40, 0x6f, 0x3e, 0x66, 0xab,
	0x54, 0x9b, 0x7f, 0xf7, 0x65, 0xd6, 0xa4, 0x9f, 0x74, 0x1f, 0xb3, 0xb5, 0x39, 0x91, 0xfc, 0x13,
	0xf7, 0xee, 0x43, 0x56, 0xdb, 0x51, 0x8a, 0xdf, 0x61, 0x0d, 0x33, 0x19, 0xc0, 0xf4, 0x76, 0x50,
	0x84, 0xed, 0x42, 0x84, 0xfb, 0x93, 0xc1, 0x6c, 0x80, 0x17, 0x26, 0xdd, 0x84, 0x35, 0x72, 0xfc,
	0x94, 0xef, 0xc1, 0x8b, 0xac, 0x06, 0x7d, 0x54, 0xf9, 0x9f, 0x17, 0xfa, 0x47, 0xb0, 0xba, 0xaf,
	0x8c, 0x57, 0x59, 0xe7, 0x88, 0xc0, 0x0c, 0xc9, 0x3b, 0x97, 0xfe, 0xdb, 0x94, 0x43, 0x4f, 0x1e,
	0xfc, 0x7c, 0xec, 0x9e, 0x79, 0x77, 0xec, 0x3a, 0xbf, 0x1f, 0xbb, 0xce, 0x1f, 0xc7, 0xae, 0xf3,
	0xf5, 0xd4, 0x75, 0xbe, 0x9f, 0xba, 0xce, 0x0f, 0x53, 0xd7, 0xf9, 0x71, 0xea, 0x3a, 0x6f, 0xa7,
	0xae, 0xf3, 0xd3, 0xd4, 0x75, 0xde, 0x4d, 0x5d, 0xe7, 0xbb, 0xdf, 0xdc, 0x33, 0x7f, 0x05, 0x00,
	0x00, 0xff, 0xff, 0x0d, 0xb5, 0x2f, 0xc0, 0xe0, 0x0f, 0x00, 0x00,
}
