// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: match_lists.proto

/*
	Package RPCProto is a generated protocol buffer package.

	It is generated from these files:
		match_lists.proto

	It has these top-level messages:
		MatchListsRequest
		Id
		MatchListsResponse
		Delete
		Update
		MatchIcon
		List
		Fee
		SubFee
*/
package RPCProto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import bytes "bytes"

import strings "strings"
import reflect "reflect"
import sortkeys "github.com/gogo/protobuf/sortkeys"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// match.lists 请求参数
type MatchListsRequest struct {
	Cmd              uint64 `protobuf:"varint,1,opt,name=cmd" json:"cmd"`
	App              uint64 `protobuf:"varint,2,opt,name=app" json:"app"`
	GameId           uint64 `protobuf:"varint,3,opt,name=game_id,json=gameId" json:"game_id"`
	Mid              uint64 `protobuf:"varint,4,opt,name=mid" json:"mid"`
	Ssid             string `protobuf:"bytes,5,opt,name=ssid" json:"ssid"`
	Action           string `protobuf:"bytes,6,opt,name=action" json:"action"`
	Page             uint32 `protobuf:"varint,7,opt,name=page" json:"page"`
	Timestamp        uint64 `protobuf:"varint,8,opt,name=timestamp" json:"timestamp"`
	Seq              uint32 `protobuf:"varint,9,opt,name=seq" json:"seq"`
	Ids              []Id   `protobuf:"bytes,10,rep,name=ids" json:"ids"`
	HallVersion      uint32 `protobuf:"varint,11,opt,name=hall_version,json=hallVersion" json:"hall_version"`
	AreaId           uint32 `protobuf:"varint,12,opt,name=area_id,json=areaId" json:"area_id"`
	IsNew            uint32 `protobuf:"varint,13,opt,name=isNew" json:"isNew"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *MatchListsRequest) Reset()                    { *m = MatchListsRequest{} }
func (*MatchListsRequest) ProtoMessage()               {}
func (*MatchListsRequest) Descriptor() ([]byte, []int) { return fileDescriptorMatchLists, []int{0} }

func (m *MatchListsRequest) GetCmd() uint64 {
	if m != nil {
		return m.Cmd
	}
	return 0
}

func (m *MatchListsRequest) GetApp() uint64 {
	if m != nil {
		return m.App
	}
	return 0
}

func (m *MatchListsRequest) GetGameId() uint64 {
	if m != nil {
		return m.GameId
	}
	return 0
}

func (m *MatchListsRequest) GetMid() uint64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *MatchListsRequest) GetSsid() string {
	if m != nil {
		return m.Ssid
	}
	return ""
}

func (m *MatchListsRequest) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *MatchListsRequest) GetPage() uint32 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *MatchListsRequest) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *MatchListsRequest) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *MatchListsRequest) GetIds() []Id {
	if m != nil {
		return m.Ids
	}
	return nil
}

func (m *MatchListsRequest) GetHallVersion() uint32 {
	if m != nil {
		return m.HallVersion
	}
	return 0
}

func (m *MatchListsRequest) GetAreaId() uint32 {
	if m != nil {
		return m.AreaId
	}
	return 0
}

func (m *MatchListsRequest) GetIsNew() uint32 {
	if m != nil {
		return m.IsNew
	}
	return 0
}

type Id struct {
	Type             uint32 `protobuf:"varint,1,opt,name=type" json:"type"`
	Id               uint64 `protobuf:"varint,2,opt,name=id" json:"id"`
	Configid         uint64 `protobuf:"varint,3,opt,name=configid" json:"configid"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Id) Reset()                    { *m = Id{} }
func (*Id) ProtoMessage()               {}
func (*Id) Descriptor() ([]byte, []int) { return fileDescriptorMatchLists, []int{1} }

func (m *Id) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Id) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Id) GetConfigid() uint64 {
	if m != nil {
		return m.Configid
	}
	return 0
}

// match.lists 返回参数
type MatchListsResponse struct {
	Tpage            uint64               `protobuf:"varint,1,opt,name=tpage" json:"tpage"`
	Srvtime          uint64               `protobuf:"varint,2,opt,name=srvtime" json:"srvtime"`
	List             map[uint32]List      `protobuf:"bytes,3,rep,name=list" json:"list" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Filter           uint32               `protobuf:"varint,4,opt,name=filter" json:"filter"`
	Iconmax          uint32               `protobuf:"varint,5,opt,name=iconmax" json:"iconmax"`
	Pnum             uint32               `protobuf:"varint,6,opt,name=pnum" json:"pnum"`
	Apply            []uint64             `protobuf:"varint,7,rep,name=apply" json:"apply,omitempty"`
	Delete           []Delete             `protobuf:"bytes,8,rep,name=delete" json:"delete"`
	Update           []Update             `protobuf:"bytes,9,rep,name=update" json:"update"`
	MatchIcons       map[string]MatchIcon `protobuf:"bytes,10,rep,name=match_icons,json=matchIcons" json:"match_icons" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Sort             map[string]uint32    `protobuf:"bytes,11,rep,name=sort" json:"sort" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *MatchListsResponse) Reset()                    { *m = MatchListsResponse{} }
func (*MatchListsResponse) ProtoMessage()               {}
func (*MatchListsResponse) Descriptor() ([]byte, []int) { return fileDescriptorMatchLists, []int{2} }

func (m *MatchListsResponse) GetTpage() uint64 {
	if m != nil {
		return m.Tpage
	}
	return 0
}

func (m *MatchListsResponse) GetSrvtime() uint64 {
	if m != nil {
		return m.Srvtime
	}
	return 0
}

func (m *MatchListsResponse) GetList() map[uint32]List {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *MatchListsResponse) GetFilter() uint32 {
	if m != nil {
		return m.Filter
	}
	return 0
}

func (m *MatchListsResponse) GetIconmax() uint32 {
	if m != nil {
		return m.Iconmax
	}
	return 0
}

func (m *MatchListsResponse) GetPnum() uint32 {
	if m != nil {
		return m.Pnum
	}
	return 0
}

func (m *MatchListsResponse) GetApply() []uint64 {
	if m != nil {
		return m.Apply
	}
	return nil
}

func (m *MatchListsResponse) GetDelete() []Delete {
	if m != nil {
		return m.Delete
	}
	return nil
}

func (m *MatchListsResponse) GetUpdate() []Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *MatchListsResponse) GetMatchIcons() map[string]MatchIcon {
	if m != nil {
		return m.MatchIcons
	}
	return nil
}

func (m *MatchListsResponse) GetSort() map[string]uint32 {
	if m != nil {
		return m.Sort
	}
	return nil
}

type Delete struct {
	Id               uint64 `protobuf:"varint,1,opt,name=id" json:"id"`
	Type             uint32 `protobuf:"varint,2,opt,name=type" json:"type"`
	Configid         uint64 `protobuf:"varint,3,opt,name=configid" json:"configid"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Delete) Reset()                    { *m = Delete{} }
func (*Delete) ProtoMessage()               {}
func (*Delete) Descriptor() ([]byte, []int) { return fileDescriptorMatchLists, []int{3} }

func (m *Delete) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Delete) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Delete) GetConfigid() uint64 {
	if m != nil {
		return m.Configid
	}
	return 0
}

type Update struct {
	Id               uint64 `protobuf:"varint,1,opt,name=id" json:"id"`
	Type             uint32 `protobuf:"varint,2,opt,name=type" json:"type"`
	Configid         uint64 `protobuf:"varint,3,opt,name=configid" json:"configid"`
	Applynum         uint64 `protobuf:"varint,4,opt,name=applynum" json:"applynum"`
	Allapplynum      uint64 `protobuf:"varint,5,opt,name=allapplynum" json:"allapplynum"`
	Stime            uint64 `protobuf:"varint,6,opt,name=stime" json:"stime"`
	Etime            uint64 `protobuf:"varint,7,opt,name=etime" json:"etime"`
	Status           uint32 `protobuf:"varint,8,opt,name=status" json:"status"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Update) Reset()                    { *m = Update{} }
func (*Update) ProtoMessage()               {}
func (*Update) Descriptor() ([]byte, []int) { return fileDescriptorMatchLists, []int{4} }

func (m *Update) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Update) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Update) GetConfigid() uint64 {
	if m != nil {
		return m.Configid
	}
	return 0
}

func (m *Update) GetApplynum() uint64 {
	if m != nil {
		return m.Applynum
	}
	return 0
}

func (m *Update) GetAllapplynum() uint64 {
	if m != nil {
		return m.Allapplynum
	}
	return 0
}

func (m *Update) GetStime() uint64 {
	if m != nil {
		return m.Stime
	}
	return 0
}

func (m *Update) GetEtime() uint64 {
	if m != nil {
		return m.Etime
	}
	return 0
}

func (m *Update) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type MatchIcon struct {
	Icon             string `protobuf:"bytes,1,opt,name=icon" json:"icon"`
	Color            string `protobuf:"bytes,2,opt,name=color" json:"color"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *MatchIcon) Reset()                    { *m = MatchIcon{} }
func (*MatchIcon) ProtoMessage()               {}
func (*MatchIcon) Descriptor() ([]byte, []int) { return fileDescriptorMatchLists, []int{5} }

func (m *MatchIcon) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *MatchIcon) GetColor() string {
	if m != nil {
		return m.Color
	}
	return ""
}

type List struct {
	Id                  uint64            `protobuf:"varint,1,opt,name=id" json:"id"`
	Type                uint32            `protobuf:"varint,2,opt,name=type" json:"type"`
	Mname               string            `protobuf:"bytes,3,opt,name=mname" json:"mname"`
	Micon               string            `protobuf:"bytes,4,opt,name=micon" json:"micon"`
	Iconweight          string            `protobuf:"bytes,5,opt,name=iconweight" json:"iconweight"`
	AdIcon              string            `protobuf:"bytes,6,opt,name=adIcon" json:"adIcon"`
	ListSort            string            `protobuf:"bytes,7,opt,name=listSort" json:"listSort"`
	Stime               uint64            `protobuf:"varint,8,opt,name=stime" json:"stime"`
	Etime               uint64            `protobuf:"varint,9,opt,name=etime" json:"etime"`
	Gameid              uint64            `protobuf:"varint,10,opt,name=gameid" json:"gameid"`
	Gamesort            uint64            `protobuf:"varint,11,opt,name=gamesort" json:"gamesort"`
	Requestnum          uint64            `protobuf:"varint,12,opt,name=requestnum" json:"requestnum"`
	Applynum            uint64            `protobuf:"varint,13,opt,name=applynum" json:"applynum"`
	Allowwaittime       uint32            `protobuf:"varint,14,opt,name=allowwaittime" json:"allowwaittime"`
	Champion            string            `protobuf:"bytes,15,opt,name=champion" json:"champion"`
	Fee                 []Fee             `protobuf:"bytes,16,rep,name=fee" json:"fee"`
	Status              uint32            `protobuf:"varint,17,opt,name=status" json:"status"`
	Looptype            uint32            `protobuf:"varint,18,opt,name=looptype" json:"looptype"`
	Loopinterval        float32           `protobuf:"fixed32,19,opt,name=loopinterval" json:"loopinterval"`
	Loopendtime         string            `protobuf:"bytes,20,opt,name=loopendtime" json:"loopendtime"`
	RewardUrl           string            `protobuf:"bytes,21,opt,name=rewardUrl" json:"rewardUrl"`
	RewardDescribe      string            `protobuf:"bytes,22,opt,name=rewardDescribe" json:"rewardDescribe"`
	ThresholdType       float64           `protobuf:"fixed64,23,opt,name=thresholdType" json:"thresholdType"`
	Threshold           float64           `protobuf:"fixed64,24,opt,name=threshold" json:"threshold"`
	Configid            uint64            `protobuf:"varint,25,opt,name=configid" json:"configid"`
	Matchtags           string            `protobuf:"bytes,26,opt,name=matchtags" json:"matchtags"`
	Matchentrycode      string            `protobuf:"bytes,27,opt,name=matchentrycode" json:"matchentrycode"`
	Matchentryinfo      string            `protobuf:"bytes,28,opt,name=matchentryinfo" json:"matchentryinfo"`
	Sname               string            `protobuf:"bytes,29,opt,name=sname" json:"sname"`
	Gamename            string            `protobuf:"bytes,30,opt,name=gamename" json:"gamename"`
	Advicon             string            `protobuf:"bytes,31,opt,name=advicon" json:"advicon"`
	Maxawardpool        uint32            `protobuf:"varint,32,opt,name=maxawardpool" json:"maxawardpool"`
	Mclabel             string            `protobuf:"bytes,33,opt,name=mclabel" json:"mclabel"`
	Allapplynum         uint64            `protobuf:"varint,34,opt,name=allapplynum" json:"allapplynum"`
	AllFreeTimes        uint32            `protobuf:"varint,35,opt,name=allFreeTimes" json:"allFreeTimes"`
	FreeTimes           uint32            `protobuf:"varint,36,opt,name=freeTimes" json:"freeTimes"`
	Moneylimit          map[string]string `protobuf:"bytes,37,rep,name=moneylimit" json:"moneylimit" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Recommendmatchcfgid uint64            `protobuf:"varint,38,opt,name=recommendmatchcfgid" json:"recommendmatchcfgid"`
	Endtime             uint64            `protobuf:"varint,39,opt,name=endtime" json:"endtime"`
	Matchpartitions     uint64            `protobuf:"varint,40,opt,name=matchpartitions" json:"matchpartitions"`
	Isfhmatch           uint32            `protobuf:"varint,41,opt,name=isfhmatch" json:"isfhmatch"`
	Loopintervaltime    uint64            `protobuf:"varint,42,opt,name=loopintervaltime" json:"loopintervaltime"`
	Firstbegintime      uint64            `protobuf:"varint,43,opt,name=firstbegintime" json:"firstbegintime"`
	XXX_unrecognized    []byte            `json:"-"`
}

func (m *List) Reset()                    { *m = List{} }
func (*List) ProtoMessage()               {}
func (*List) Descriptor() ([]byte, []int) { return fileDescriptorMatchLists, []int{6} }

func (m *List) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *List) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *List) GetMname() string {
	if m != nil {
		return m.Mname
	}
	return ""
}

func (m *List) GetMicon() string {
	if m != nil {
		return m.Micon
	}
	return ""
}

func (m *List) GetIconweight() string {
	if m != nil {
		return m.Iconweight
	}
	return ""
}

func (m *List) GetAdIcon() string {
	if m != nil {
		return m.AdIcon
	}
	return ""
}

func (m *List) GetListSort() string {
	if m != nil {
		return m.ListSort
	}
	return ""
}

func (m *List) GetStime() uint64 {
	if m != nil {
		return m.Stime
	}
	return 0
}

func (m *List) GetEtime() uint64 {
	if m != nil {
		return m.Etime
	}
	return 0
}

func (m *List) GetGameid() uint64 {
	if m != nil {
		return m.Gameid
	}
	return 0
}

func (m *List) GetGamesort() uint64 {
	if m != nil {
		return m.Gamesort
	}
	return 0
}

func (m *List) GetRequestnum() uint64 {
	if m != nil {
		return m.Requestnum
	}
	return 0
}

func (m *List) GetApplynum() uint64 {
	if m != nil {
		return m.Applynum
	}
	return 0
}

func (m *List) GetAllowwaittime() uint32 {
	if m != nil {
		return m.Allowwaittime
	}
	return 0
}

func (m *List) GetChampion() string {
	if m != nil {
		return m.Champion
	}
	return ""
}

func (m *List) GetFee() []Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

func (m *List) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *List) GetLooptype() uint32 {
	if m != nil {
		return m.Looptype
	}
	return 0
}

func (m *List) GetLoopinterval() float32 {
	if m != nil {
		return m.Loopinterval
	}
	return 0
}

func (m *List) GetLoopendtime() string {
	if m != nil {
		return m.Loopendtime
	}
	return ""
}

func (m *List) GetRewardUrl() string {
	if m != nil {
		return m.RewardUrl
	}
	return ""
}

func (m *List) GetRewardDescribe() string {
	if m != nil {
		return m.RewardDescribe
	}
	return ""
}

func (m *List) GetThresholdType() float64 {
	if m != nil {
		return m.ThresholdType
	}
	return 0
}

func (m *List) GetThreshold() float64 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *List) GetConfigid() uint64 {
	if m != nil {
		return m.Configid
	}
	return 0
}

func (m *List) GetMatchtags() string {
	if m != nil {
		return m.Matchtags
	}
	return ""
}

func (m *List) GetMatchentrycode() string {
	if m != nil {
		return m.Matchentrycode
	}
	return ""
}

func (m *List) GetMatchentryinfo() string {
	if m != nil {
		return m.Matchentryinfo
	}
	return ""
}

func (m *List) GetSname() string {
	if m != nil {
		return m.Sname
	}
	return ""
}

func (m *List) GetGamename() string {
	if m != nil {
		return m.Gamename
	}
	return ""
}

func (m *List) GetAdvicon() string {
	if m != nil {
		return m.Advicon
	}
	return ""
}

func (m *List) GetMaxawardpool() uint32 {
	if m != nil {
		return m.Maxawardpool
	}
	return 0
}

func (m *List) GetMclabel() string {
	if m != nil {
		return m.Mclabel
	}
	return ""
}

func (m *List) GetAllapplynum() uint64 {
	if m != nil {
		return m.Allapplynum
	}
	return 0
}

func (m *List) GetAllFreeTimes() uint32 {
	if m != nil {
		return m.AllFreeTimes
	}
	return 0
}

func (m *List) GetFreeTimes() uint32 {
	if m != nil {
		return m.FreeTimes
	}
	return 0
}

func (m *List) GetMoneylimit() map[string]string {
	if m != nil {
		return m.Moneylimit
	}
	return nil
}

func (m *List) GetRecommendmatchcfgid() uint64 {
	if m != nil {
		return m.Recommendmatchcfgid
	}
	return 0
}

func (m *List) GetEndtime() uint64 {
	if m != nil {
		return m.Endtime
	}
	return 0
}

func (m *List) GetMatchpartitions() uint64 {
	if m != nil {
		return m.Matchpartitions
	}
	return 0
}

func (m *List) GetIsfhmatch() uint32 {
	if m != nil {
		return m.Isfhmatch
	}
	return 0
}

func (m *List) GetLoopintervaltime() uint64 {
	if m != nil {
		return m.Loopintervaltime
	}
	return 0
}

func (m *List) GetFirstbegintime() uint64 {
	if m != nil {
		return m.Firstbegintime
	}
	return 0
}

// 道具类型 道具数量 道具描述 优惠标签（1为开启）（特殊处理化金币和钻石。0为金币、2为钻石）
type Fee struct {
	Subfee           []SubFee `protobuf:"bytes,1,rep,name=subfee" json:"subfee"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Fee) Reset()                    { *m = Fee{} }
func (*Fee) ProtoMessage()               {}
func (*Fee) Descriptor() ([]byte, []int) { return fileDescriptorMatchLists, []int{7} }

func (m *Fee) GetSubfee() []SubFee {
	if m != nil {
		return m.Subfee
	}
	return nil
}

type SubFee struct {
	Type             uint32 `protobuf:"varint,1,opt,name=type" json:"type"`
	Num              uint64 `protobuf:"varint,2,opt,name=num" json:"num"`
	Desc             string `protobuf:"bytes,3,opt,name=desc" json:"desc"`
	Label            uint32 `protobuf:"varint,4,opt,name=label" json:"label"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SubFee) Reset()                    { *m = SubFee{} }
func (*SubFee) ProtoMessage()               {}
func (*SubFee) Descriptor() ([]byte, []int) { return fileDescriptorMatchLists, []int{8} }

func (m *SubFee) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *SubFee) GetNum() uint64 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *SubFee) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *SubFee) GetLabel() uint32 {
	if m != nil {
		return m.Label
	}
	return 0
}

func init() {
	proto.RegisterType((*MatchListsRequest)(nil), "RPCProto.MatchListsRequest")
	proto.RegisterType((*Id)(nil), "RPCProto.Id")
	proto.RegisterType((*MatchListsResponse)(nil), "RPCProto.MatchListsResponse")
	proto.RegisterType((*Delete)(nil), "RPCProto.Delete")
	proto.RegisterType((*Update)(nil), "RPCProto.Update")
	proto.RegisterType((*MatchIcon)(nil), "RPCProto.MatchIcon")
	proto.RegisterType((*List)(nil), "RPCProto.List")
	proto.RegisterType((*Fee)(nil), "RPCProto.Fee")
	proto.RegisterType((*SubFee)(nil), "RPCProto.SubFee")
}
func (this *MatchListsRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*MatchListsRequest)
	if !ok {
		that2, ok := that.(MatchListsRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *MatchListsRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *MatchListsRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *MatchListsRequest but is not nil && this == nil")
	}
	if this.Cmd != that1.Cmd {
		return fmt.Errorf("Cmd this(%v) Not Equal that(%v)", this.Cmd, that1.Cmd)
	}
	if this.App != that1.App {
		return fmt.Errorf("App this(%v) Not Equal that(%v)", this.App, that1.App)
	}
	if this.GameId != that1.GameId {
		return fmt.Errorf("GameId this(%v) Not Equal that(%v)", this.GameId, that1.GameId)
	}
	if this.Mid != that1.Mid {
		return fmt.Errorf("Mid this(%v) Not Equal that(%v)", this.Mid, that1.Mid)
	}
	if this.Ssid != that1.Ssid {
		return fmt.Errorf("Ssid this(%v) Not Equal that(%v)", this.Ssid, that1.Ssid)
	}
	if this.Action != that1.Action {
		return fmt.Errorf("Action this(%v) Not Equal that(%v)", this.Action, that1.Action)
	}
	if this.Page != that1.Page {
		return fmt.Errorf("Page this(%v) Not Equal that(%v)", this.Page, that1.Page)
	}
	if this.Timestamp != that1.Timestamp {
		return fmt.Errorf("Timestamp this(%v) Not Equal that(%v)", this.Timestamp, that1.Timestamp)
	}
	if this.Seq != that1.Seq {
		return fmt.Errorf("Seq this(%v) Not Equal that(%v)", this.Seq, that1.Seq)
	}
	if len(this.Ids) != len(that1.Ids) {
		return fmt.Errorf("Ids this(%v) Not Equal that(%v)", len(this.Ids), len(that1.Ids))
	}
	for i := range this.Ids {
		if !this.Ids[i].Equal(&that1.Ids[i]) {
			return fmt.Errorf("Ids this[%v](%v) Not Equal that[%v](%v)", i, this.Ids[i], i, that1.Ids[i])
		}
	}
	if this.HallVersion != that1.HallVersion {
		return fmt.Errorf("HallVersion this(%v) Not Equal that(%v)", this.HallVersion, that1.HallVersion)
	}
	if this.AreaId != that1.AreaId {
		return fmt.Errorf("AreaId this(%v) Not Equal that(%v)", this.AreaId, that1.AreaId)
	}
	if this.IsNew != that1.IsNew {
		return fmt.Errorf("IsNew this(%v) Not Equal that(%v)", this.IsNew, that1.IsNew)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *MatchListsRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchListsRequest)
	if !ok {
		that2, ok := that.(MatchListsRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Cmd != that1.Cmd {
		return false
	}
	if this.App != that1.App {
		return false
	}
	if this.GameId != that1.GameId {
		return false
	}
	if this.Mid != that1.Mid {
		return false
	}
	if this.Ssid != that1.Ssid {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if this.Page != that1.Page {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if this.Seq != that1.Seq {
		return false
	}
	if len(this.Ids) != len(that1.Ids) {
		return false
	}
	for i := range this.Ids {
		if !this.Ids[i].Equal(&that1.Ids[i]) {
			return false
		}
	}
	if this.HallVersion != that1.HallVersion {
		return false
	}
	if this.AreaId != that1.AreaId {
		return false
	}
	if this.IsNew != that1.IsNew {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Id) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Id)
	if !ok {
		that2, ok := that.(Id)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Id")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Id but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Id but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Configid != that1.Configid {
		return fmt.Errorf("Configid this(%v) Not Equal that(%v)", this.Configid, that1.Configid)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Id) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Id)
	if !ok {
		that2, ok := that.(Id)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Configid != that1.Configid {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *MatchListsResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*MatchListsResponse)
	if !ok {
		that2, ok := that.(MatchListsResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *MatchListsResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *MatchListsResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *MatchListsResponse but is not nil && this == nil")
	}
	if this.Tpage != that1.Tpage {
		return fmt.Errorf("Tpage this(%v) Not Equal that(%v)", this.Tpage, that1.Tpage)
	}
	if this.Srvtime != that1.Srvtime {
		return fmt.Errorf("Srvtime this(%v) Not Equal that(%v)", this.Srvtime, that1.Srvtime)
	}
	if len(this.List) != len(that1.List) {
		return fmt.Errorf("List this(%v) Not Equal that(%v)", len(this.List), len(that1.List))
	}
	for i := range this.List {
		a := this.List[i]
		b := that1.List[i]
		if !(&a).Equal(&b) {
			return fmt.Errorf("List this[%v](%v) Not Equal that[%v](%v)", i, this.List[i], i, that1.List[i])
		}
	}
	if this.Filter != that1.Filter {
		return fmt.Errorf("Filter this(%v) Not Equal that(%v)", this.Filter, that1.Filter)
	}
	if this.Iconmax != that1.Iconmax {
		return fmt.Errorf("Iconmax this(%v) Not Equal that(%v)", this.Iconmax, that1.Iconmax)
	}
	if this.Pnum != that1.Pnum {
		return fmt.Errorf("Pnum this(%v) Not Equal that(%v)", this.Pnum, that1.Pnum)
	}
	if len(this.Apply) != len(that1.Apply) {
		return fmt.Errorf("Apply this(%v) Not Equal that(%v)", len(this.Apply), len(that1.Apply))
	}
	for i := range this.Apply {
		if this.Apply[i] != that1.Apply[i] {
			return fmt.Errorf("Apply this[%v](%v) Not Equal that[%v](%v)", i, this.Apply[i], i, that1.Apply[i])
		}
	}
	if len(this.Delete) != len(that1.Delete) {
		return fmt.Errorf("Delete this(%v) Not Equal that(%v)", len(this.Delete), len(that1.Delete))
	}
	for i := range this.Delete {
		if !this.Delete[i].Equal(&that1.Delete[i]) {
			return fmt.Errorf("Delete this[%v](%v) Not Equal that[%v](%v)", i, this.Delete[i], i, that1.Delete[i])
		}
	}
	if len(this.Update) != len(that1.Update) {
		return fmt.Errorf("Update this(%v) Not Equal that(%v)", len(this.Update), len(that1.Update))
	}
	for i := range this.Update {
		if !this.Update[i].Equal(&that1.Update[i]) {
			return fmt.Errorf("Update this[%v](%v) Not Equal that[%v](%v)", i, this.Update[i], i, that1.Update[i])
		}
	}
	if len(this.MatchIcons) != len(that1.MatchIcons) {
		return fmt.Errorf("MatchIcons this(%v) Not Equal that(%v)", len(this.MatchIcons), len(that1.MatchIcons))
	}
	for i := range this.MatchIcons {
		a := this.MatchIcons[i]
		b := that1.MatchIcons[i]
		if !(&a).Equal(&b) {
			return fmt.Errorf("MatchIcons this[%v](%v) Not Equal that[%v](%v)", i, this.MatchIcons[i], i, that1.MatchIcons[i])
		}
	}
	if len(this.Sort) != len(that1.Sort) {
		return fmt.Errorf("Sort this(%v) Not Equal that(%v)", len(this.Sort), len(that1.Sort))
	}
	for i := range this.Sort {
		if this.Sort[i] != that1.Sort[i] {
			return fmt.Errorf("Sort this[%v](%v) Not Equal that[%v](%v)", i, this.Sort[i], i, that1.Sort[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *MatchListsResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchListsResponse)
	if !ok {
		that2, ok := that.(MatchListsResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Tpage != that1.Tpage {
		return false
	}
	if this.Srvtime != that1.Srvtime {
		return false
	}
	if len(this.List) != len(that1.List) {
		return false
	}
	for i := range this.List {
		a := this.List[i]
		b := that1.List[i]
		if !(&a).Equal(&b) {
			return false
		}
	}
	if this.Filter != that1.Filter {
		return false
	}
	if this.Iconmax != that1.Iconmax {
		return false
	}
	if this.Pnum != that1.Pnum {
		return false
	}
	if len(this.Apply) != len(that1.Apply) {
		return false
	}
	for i := range this.Apply {
		if this.Apply[i] != that1.Apply[i] {
			return false
		}
	}
	if len(this.Delete) != len(that1.Delete) {
		return false
	}
	for i := range this.Delete {
		if !this.Delete[i].Equal(&that1.Delete[i]) {
			return false
		}
	}
	if len(this.Update) != len(that1.Update) {
		return false
	}
	for i := range this.Update {
		if !this.Update[i].Equal(&that1.Update[i]) {
			return false
		}
	}
	if len(this.MatchIcons) != len(that1.MatchIcons) {
		return false
	}
	for i := range this.MatchIcons {
		a := this.MatchIcons[i]
		b := that1.MatchIcons[i]
		if !(&a).Equal(&b) {
			return false
		}
	}
	if len(this.Sort) != len(that1.Sort) {
		return false
	}
	for i := range this.Sort {
		if this.Sort[i] != that1.Sort[i] {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Delete) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Delete)
	if !ok {
		that2, ok := that.(Delete)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Delete")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Delete but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Delete but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Configid != that1.Configid {
		return fmt.Errorf("Configid this(%v) Not Equal that(%v)", this.Configid, that1.Configid)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Delete) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Delete)
	if !ok {
		that2, ok := that.(Delete)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Configid != that1.Configid {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Update) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Update)
	if !ok {
		that2, ok := that.(Update)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Update")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Update but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Update but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Configid != that1.Configid {
		return fmt.Errorf("Configid this(%v) Not Equal that(%v)", this.Configid, that1.Configid)
	}
	if this.Applynum != that1.Applynum {
		return fmt.Errorf("Applynum this(%v) Not Equal that(%v)", this.Applynum, that1.Applynum)
	}
	if this.Allapplynum != that1.Allapplynum {
		return fmt.Errorf("Allapplynum this(%v) Not Equal that(%v)", this.Allapplynum, that1.Allapplynum)
	}
	if this.Stime != that1.Stime {
		return fmt.Errorf("Stime this(%v) Not Equal that(%v)", this.Stime, that1.Stime)
	}
	if this.Etime != that1.Etime {
		return fmt.Errorf("Etime this(%v) Not Equal that(%v)", this.Etime, that1.Etime)
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Update) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Update)
	if !ok {
		that2, ok := that.(Update)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Configid != that1.Configid {
		return false
	}
	if this.Applynum != that1.Applynum {
		return false
	}
	if this.Allapplynum != that1.Allapplynum {
		return false
	}
	if this.Stime != that1.Stime {
		return false
	}
	if this.Etime != that1.Etime {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *MatchIcon) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*MatchIcon)
	if !ok {
		that2, ok := that.(MatchIcon)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *MatchIcon")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *MatchIcon but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *MatchIcon but is not nil && this == nil")
	}
	if this.Icon != that1.Icon {
		return fmt.Errorf("Icon this(%v) Not Equal that(%v)", this.Icon, that1.Icon)
	}
	if this.Color != that1.Color {
		return fmt.Errorf("Color this(%v) Not Equal that(%v)", this.Color, that1.Color)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *MatchIcon) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MatchIcon)
	if !ok {
		that2, ok := that.(MatchIcon)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Icon != that1.Icon {
		return false
	}
	if this.Color != that1.Color {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *List) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*List)
	if !ok {
		that2, ok := that.(List)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *List")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *List but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *List but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Mname != that1.Mname {
		return fmt.Errorf("Mname this(%v) Not Equal that(%v)", this.Mname, that1.Mname)
	}
	if this.Micon != that1.Micon {
		return fmt.Errorf("Micon this(%v) Not Equal that(%v)", this.Micon, that1.Micon)
	}
	if this.Iconweight != that1.Iconweight {
		return fmt.Errorf("Iconweight this(%v) Not Equal that(%v)", this.Iconweight, that1.Iconweight)
	}
	if this.AdIcon != that1.AdIcon {
		return fmt.Errorf("AdIcon this(%v) Not Equal that(%v)", this.AdIcon, that1.AdIcon)
	}
	if this.ListSort != that1.ListSort {
		return fmt.Errorf("ListSort this(%v) Not Equal that(%v)", this.ListSort, that1.ListSort)
	}
	if this.Stime != that1.Stime {
		return fmt.Errorf("Stime this(%v) Not Equal that(%v)", this.Stime, that1.Stime)
	}
	if this.Etime != that1.Etime {
		return fmt.Errorf("Etime this(%v) Not Equal that(%v)", this.Etime, that1.Etime)
	}
	if this.Gameid != that1.Gameid {
		return fmt.Errorf("Gameid this(%v) Not Equal that(%v)", this.Gameid, that1.Gameid)
	}
	if this.Gamesort != that1.Gamesort {
		return fmt.Errorf("Gamesort this(%v) Not Equal that(%v)", this.Gamesort, that1.Gamesort)
	}
	if this.Requestnum != that1.Requestnum {
		return fmt.Errorf("Requestnum this(%v) Not Equal that(%v)", this.Requestnum, that1.Requestnum)
	}
	if this.Applynum != that1.Applynum {
		return fmt.Errorf("Applynum this(%v) Not Equal that(%v)", this.Applynum, that1.Applynum)
	}
	if this.Allowwaittime != that1.Allowwaittime {
		return fmt.Errorf("Allowwaittime this(%v) Not Equal that(%v)", this.Allowwaittime, that1.Allowwaittime)
	}
	if this.Champion != that1.Champion {
		return fmt.Errorf("Champion this(%v) Not Equal that(%v)", this.Champion, that1.Champion)
	}
	if len(this.Fee) != len(that1.Fee) {
		return fmt.Errorf("Fee this(%v) Not Equal that(%v)", len(this.Fee), len(that1.Fee))
	}
	for i := range this.Fee {
		if !this.Fee[i].Equal(&that1.Fee[i]) {
			return fmt.Errorf("Fee this[%v](%v) Not Equal that[%v](%v)", i, this.Fee[i], i, that1.Fee[i])
		}
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if this.Looptype != that1.Looptype {
		return fmt.Errorf("Looptype this(%v) Not Equal that(%v)", this.Looptype, that1.Looptype)
	}
	if this.Loopinterval != that1.Loopinterval {
		return fmt.Errorf("Loopinterval this(%v) Not Equal that(%v)", this.Loopinterval, that1.Loopinterval)
	}
	if this.Loopendtime != that1.Loopendtime {
		return fmt.Errorf("Loopendtime this(%v) Not Equal that(%v)", this.Loopendtime, that1.Loopendtime)
	}
	if this.RewardUrl != that1.RewardUrl {
		return fmt.Errorf("RewardUrl this(%v) Not Equal that(%v)", this.RewardUrl, that1.RewardUrl)
	}
	if this.RewardDescribe != that1.RewardDescribe {
		return fmt.Errorf("RewardDescribe this(%v) Not Equal that(%v)", this.RewardDescribe, that1.RewardDescribe)
	}
	if this.ThresholdType != that1.ThresholdType {
		return fmt.Errorf("ThresholdType this(%v) Not Equal that(%v)", this.ThresholdType, that1.ThresholdType)
	}
	if this.Threshold != that1.Threshold {
		return fmt.Errorf("Threshold this(%v) Not Equal that(%v)", this.Threshold, that1.Threshold)
	}
	if this.Configid != that1.Configid {
		return fmt.Errorf("Configid this(%v) Not Equal that(%v)", this.Configid, that1.Configid)
	}
	if this.Matchtags != that1.Matchtags {
		return fmt.Errorf("Matchtags this(%v) Not Equal that(%v)", this.Matchtags, that1.Matchtags)
	}
	if this.Matchentrycode != that1.Matchentrycode {
		return fmt.Errorf("Matchentrycode this(%v) Not Equal that(%v)", this.Matchentrycode, that1.Matchentrycode)
	}
	if this.Matchentryinfo != that1.Matchentryinfo {
		return fmt.Errorf("Matchentryinfo this(%v) Not Equal that(%v)", this.Matchentryinfo, that1.Matchentryinfo)
	}
	if this.Sname != that1.Sname {
		return fmt.Errorf("Sname this(%v) Not Equal that(%v)", this.Sname, that1.Sname)
	}
	if this.Gamename != that1.Gamename {
		return fmt.Errorf("Gamename this(%v) Not Equal that(%v)", this.Gamename, that1.Gamename)
	}
	if this.Advicon != that1.Advicon {
		return fmt.Errorf("Advicon this(%v) Not Equal that(%v)", this.Advicon, that1.Advicon)
	}
	if this.Maxawardpool != that1.Maxawardpool {
		return fmt.Errorf("Maxawardpool this(%v) Not Equal that(%v)", this.Maxawardpool, that1.Maxawardpool)
	}
	if this.Mclabel != that1.Mclabel {
		return fmt.Errorf("Mclabel this(%v) Not Equal that(%v)", this.Mclabel, that1.Mclabel)
	}
	if this.Allapplynum != that1.Allapplynum {
		return fmt.Errorf("Allapplynum this(%v) Not Equal that(%v)", this.Allapplynum, that1.Allapplynum)
	}
	if this.AllFreeTimes != that1.AllFreeTimes {
		return fmt.Errorf("AllFreeTimes this(%v) Not Equal that(%v)", this.AllFreeTimes, that1.AllFreeTimes)
	}
	if this.FreeTimes != that1.FreeTimes {
		return fmt.Errorf("FreeTimes this(%v) Not Equal that(%v)", this.FreeTimes, that1.FreeTimes)
	}
	if len(this.Moneylimit) != len(that1.Moneylimit) {
		return fmt.Errorf("Moneylimit this(%v) Not Equal that(%v)", len(this.Moneylimit), len(that1.Moneylimit))
	}
	for i := range this.Moneylimit {
		if this.Moneylimit[i] != that1.Moneylimit[i] {
			return fmt.Errorf("Moneylimit this[%v](%v) Not Equal that[%v](%v)", i, this.Moneylimit[i], i, that1.Moneylimit[i])
		}
	}
	if this.Recommendmatchcfgid != that1.Recommendmatchcfgid {
		return fmt.Errorf("Recommendmatchcfgid this(%v) Not Equal that(%v)", this.Recommendmatchcfgid, that1.Recommendmatchcfgid)
	}
	if this.Endtime != that1.Endtime {
		return fmt.Errorf("Endtime this(%v) Not Equal that(%v)", this.Endtime, that1.Endtime)
	}
	if this.Matchpartitions != that1.Matchpartitions {
		return fmt.Errorf("Matchpartitions this(%v) Not Equal that(%v)", this.Matchpartitions, that1.Matchpartitions)
	}
	if this.Isfhmatch != that1.Isfhmatch {
		return fmt.Errorf("Isfhmatch this(%v) Not Equal that(%v)", this.Isfhmatch, that1.Isfhmatch)
	}
	if this.Loopintervaltime != that1.Loopintervaltime {
		return fmt.Errorf("Loopintervaltime this(%v) Not Equal that(%v)", this.Loopintervaltime, that1.Loopintervaltime)
	}
	if this.Firstbegintime != that1.Firstbegintime {
		return fmt.Errorf("Firstbegintime this(%v) Not Equal that(%v)", this.Firstbegintime, that1.Firstbegintime)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *List) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*List)
	if !ok {
		that2, ok := that.(List)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Mname != that1.Mname {
		return false
	}
	if this.Micon != that1.Micon {
		return false
	}
	if this.Iconweight != that1.Iconweight {
		return false
	}
	if this.AdIcon != that1.AdIcon {
		return false
	}
	if this.ListSort != that1.ListSort {
		return false
	}
	if this.Stime != that1.Stime {
		return false
	}
	if this.Etime != that1.Etime {
		return false
	}
	if this.Gameid != that1.Gameid {
		return false
	}
	if this.Gamesort != that1.Gamesort {
		return false
	}
	if this.Requestnum != that1.Requestnum {
		return false
	}
	if this.Applynum != that1.Applynum {
		return false
	}
	if this.Allowwaittime != that1.Allowwaittime {
		return false
	}
	if this.Champion != that1.Champion {
		return false
	}
	if len(this.Fee) != len(that1.Fee) {
		return false
	}
	for i := range this.Fee {
		if !this.Fee[i].Equal(&that1.Fee[i]) {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Looptype != that1.Looptype {
		return false
	}
	if this.Loopinterval != that1.Loopinterval {
		return false
	}
	if this.Loopendtime != that1.Loopendtime {
		return false
	}
	if this.RewardUrl != that1.RewardUrl {
		return false
	}
	if this.RewardDescribe != that1.RewardDescribe {
		return false
	}
	if this.ThresholdType != that1.ThresholdType {
		return false
	}
	if this.Threshold != that1.Threshold {
		return false
	}
	if this.Configid != that1.Configid {
		return false
	}
	if this.Matchtags != that1.Matchtags {
		return false
	}
	if this.Matchentrycode != that1.Matchentrycode {
		return false
	}
	if this.Matchentryinfo != that1.Matchentryinfo {
		return false
	}
	if this.Sname != that1.Sname {
		return false
	}
	if this.Gamename != that1.Gamename {
		return false
	}
	if this.Advicon != that1.Advicon {
		return false
	}
	if this.Maxawardpool != that1.Maxawardpool {
		return false
	}
	if this.Mclabel != that1.Mclabel {
		return false
	}
	if this.Allapplynum != that1.Allapplynum {
		return false
	}
	if this.AllFreeTimes != that1.AllFreeTimes {
		return false
	}
	if this.FreeTimes != that1.FreeTimes {
		return false
	}
	if len(this.Moneylimit) != len(that1.Moneylimit) {
		return false
	}
	for i := range this.Moneylimit {
		if this.Moneylimit[i] != that1.Moneylimit[i] {
			return false
		}
	}
	if this.Recommendmatchcfgid != that1.Recommendmatchcfgid {
		return false
	}
	if this.Endtime != that1.Endtime {
		return false
	}
	if this.Matchpartitions != that1.Matchpartitions {
		return false
	}
	if this.Isfhmatch != that1.Isfhmatch {
		return false
	}
	if this.Loopintervaltime != that1.Loopintervaltime {
		return false
	}
	if this.Firstbegintime != that1.Firstbegintime {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Fee) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Fee)
	if !ok {
		that2, ok := that.(Fee)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Fee")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Fee but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Fee but is not nil && this == nil")
	}
	if len(this.Subfee) != len(that1.Subfee) {
		return fmt.Errorf("Subfee this(%v) Not Equal that(%v)", len(this.Subfee), len(that1.Subfee))
	}
	for i := range this.Subfee {
		if !this.Subfee[i].Equal(&that1.Subfee[i]) {
			return fmt.Errorf("Subfee this[%v](%v) Not Equal that[%v](%v)", i, this.Subfee[i], i, that1.Subfee[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Fee) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Fee)
	if !ok {
		that2, ok := that.(Fee)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Subfee) != len(that1.Subfee) {
		return false
	}
	for i := range this.Subfee {
		if !this.Subfee[i].Equal(&that1.Subfee[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *SubFee) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SubFee)
	if !ok {
		that2, ok := that.(SubFee)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SubFee")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SubFee but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SubFee but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Num != that1.Num {
		return fmt.Errorf("Num this(%v) Not Equal that(%v)", this.Num, that1.Num)
	}
	if this.Desc != that1.Desc {
		return fmt.Errorf("Desc this(%v) Not Equal that(%v)", this.Desc, that1.Desc)
	}
	if this.Label != that1.Label {
		return fmt.Errorf("Label this(%v) Not Equal that(%v)", this.Label, that1.Label)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *SubFee) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SubFee)
	if !ok {
		that2, ok := that.(SubFee)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Num != that1.Num {
		return false
	}
	if this.Desc != that1.Desc {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *MatchListsRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 17)
	s = append(s, "&RPCProto.MatchListsRequest{")
	s = append(s, "Cmd: "+fmt.Sprintf("%#v", this.Cmd)+",\n")
	s = append(s, "App: "+fmt.Sprintf("%#v", this.App)+",\n")
	s = append(s, "GameId: "+fmt.Sprintf("%#v", this.GameId)+",\n")
	s = append(s, "Mid: "+fmt.Sprintf("%#v", this.Mid)+",\n")
	s = append(s, "Ssid: "+fmt.Sprintf("%#v", this.Ssid)+",\n")
	s = append(s, "Action: "+fmt.Sprintf("%#v", this.Action)+",\n")
	s = append(s, "Page: "+fmt.Sprintf("%#v", this.Page)+",\n")
	s = append(s, "Timestamp: "+fmt.Sprintf("%#v", this.Timestamp)+",\n")
	s = append(s, "Seq: "+fmt.Sprintf("%#v", this.Seq)+",\n")
	if this.Ids != nil {
		vs := make([]*Id, len(this.Ids))
		for i := range vs {
			vs[i] = &this.Ids[i]
		}
		s = append(s, "Ids: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "HallVersion: "+fmt.Sprintf("%#v", this.HallVersion)+",\n")
	s = append(s, "AreaId: "+fmt.Sprintf("%#v", this.AreaId)+",\n")
	s = append(s, "IsNew: "+fmt.Sprintf("%#v", this.IsNew)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Id) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&RPCProto.Id{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Configid: "+fmt.Sprintf("%#v", this.Configid)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MatchListsResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 15)
	s = append(s, "&RPCProto.MatchListsResponse{")
	s = append(s, "Tpage: "+fmt.Sprintf("%#v", this.Tpage)+",\n")
	s = append(s, "Srvtime: "+fmt.Sprintf("%#v", this.Srvtime)+",\n")
	keysForList := make([]uint32, 0, len(this.List))
	for k, _ := range this.List {
		keysForList = append(keysForList, k)
	}
	sortkeys.Uint32s(keysForList)
	mapStringForList := "map[uint32]List{"
	for _, k := range keysForList {
		mapStringForList += fmt.Sprintf("%#v: %#v,", k, this.List[k])
	}
	mapStringForList += "}"
	if this.List != nil {
		s = append(s, "List: "+mapStringForList+",\n")
	}
	s = append(s, "Filter: "+fmt.Sprintf("%#v", this.Filter)+",\n")
	s = append(s, "Iconmax: "+fmt.Sprintf("%#v", this.Iconmax)+",\n")
	s = append(s, "Pnum: "+fmt.Sprintf("%#v", this.Pnum)+",\n")
	if this.Apply != nil {
		s = append(s, "Apply: "+fmt.Sprintf("%#v", this.Apply)+",\n")
	}
	if this.Delete != nil {
		vs := make([]*Delete, len(this.Delete))
		for i := range vs {
			vs[i] = &this.Delete[i]
		}
		s = append(s, "Delete: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Update != nil {
		vs := make([]*Update, len(this.Update))
		for i := range vs {
			vs[i] = &this.Update[i]
		}
		s = append(s, "Update: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	keysForMatchIcons := make([]string, 0, len(this.MatchIcons))
	for k, _ := range this.MatchIcons {
		keysForMatchIcons = append(keysForMatchIcons, k)
	}
	sortkeys.Strings(keysForMatchIcons)
	mapStringForMatchIcons := "map[string]MatchIcon{"
	for _, k := range keysForMatchIcons {
		mapStringForMatchIcons += fmt.Sprintf("%#v: %#v,", k, this.MatchIcons[k])
	}
	mapStringForMatchIcons += "}"
	if this.MatchIcons != nil {
		s = append(s, "MatchIcons: "+mapStringForMatchIcons+",\n")
	}
	keysForSort := make([]string, 0, len(this.Sort))
	for k, _ := range this.Sort {
		keysForSort = append(keysForSort, k)
	}
	sortkeys.Strings(keysForSort)
	mapStringForSort := "map[string]uint32{"
	for _, k := range keysForSort {
		mapStringForSort += fmt.Sprintf("%#v: %#v,", k, this.Sort[k])
	}
	mapStringForSort += "}"
	if this.Sort != nil {
		s = append(s, "Sort: "+mapStringForSort+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Delete) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&RPCProto.Delete{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Configid: "+fmt.Sprintf("%#v", this.Configid)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Update) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&RPCProto.Update{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Configid: "+fmt.Sprintf("%#v", this.Configid)+",\n")
	s = append(s, "Applynum: "+fmt.Sprintf("%#v", this.Applynum)+",\n")
	s = append(s, "Allapplynum: "+fmt.Sprintf("%#v", this.Allapplynum)+",\n")
	s = append(s, "Stime: "+fmt.Sprintf("%#v", this.Stime)+",\n")
	s = append(s, "Etime: "+fmt.Sprintf("%#v", this.Etime)+",\n")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MatchIcon) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&RPCProto.MatchIcon{")
	s = append(s, "Icon: "+fmt.Sprintf("%#v", this.Icon)+",\n")
	s = append(s, "Color: "+fmt.Sprintf("%#v", this.Color)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *List) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 47)
	s = append(s, "&RPCProto.List{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Mname: "+fmt.Sprintf("%#v", this.Mname)+",\n")
	s = append(s, "Micon: "+fmt.Sprintf("%#v", this.Micon)+",\n")
	s = append(s, "Iconweight: "+fmt.Sprintf("%#v", this.Iconweight)+",\n")
	s = append(s, "AdIcon: "+fmt.Sprintf("%#v", this.AdIcon)+",\n")
	s = append(s, "ListSort: "+fmt.Sprintf("%#v", this.ListSort)+",\n")
	s = append(s, "Stime: "+fmt.Sprintf("%#v", this.Stime)+",\n")
	s = append(s, "Etime: "+fmt.Sprintf("%#v", this.Etime)+",\n")
	s = append(s, "Gameid: "+fmt.Sprintf("%#v", this.Gameid)+",\n")
	s = append(s, "Gamesort: "+fmt.Sprintf("%#v", this.Gamesort)+",\n")
	s = append(s, "Requestnum: "+fmt.Sprintf("%#v", this.Requestnum)+",\n")
	s = append(s, "Applynum: "+fmt.Sprintf("%#v", this.Applynum)+",\n")
	s = append(s, "Allowwaittime: "+fmt.Sprintf("%#v", this.Allowwaittime)+",\n")
	s = append(s, "Champion: "+fmt.Sprintf("%#v", this.Champion)+",\n")
	if this.Fee != nil {
		vs := make([]*Fee, len(this.Fee))
		for i := range vs {
			vs[i] = &this.Fee[i]
		}
		s = append(s, "Fee: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Looptype: "+fmt.Sprintf("%#v", this.Looptype)+",\n")
	s = append(s, "Loopinterval: "+fmt.Sprintf("%#v", this.Loopinterval)+",\n")
	s = append(s, "Loopendtime: "+fmt.Sprintf("%#v", this.Loopendtime)+",\n")
	s = append(s, "RewardUrl: "+fmt.Sprintf("%#v", this.RewardUrl)+",\n")
	s = append(s, "RewardDescribe: "+fmt.Sprintf("%#v", this.RewardDescribe)+",\n")
	s = append(s, "ThresholdType: "+fmt.Sprintf("%#v", this.ThresholdType)+",\n")
	s = append(s, "Threshold: "+fmt.Sprintf("%#v", this.Threshold)+",\n")
	s = append(s, "Configid: "+fmt.Sprintf("%#v", this.Configid)+",\n")
	s = append(s, "Matchtags: "+fmt.Sprintf("%#v", this.Matchtags)+",\n")
	s = append(s, "Matchentrycode: "+fmt.Sprintf("%#v", this.Matchentrycode)+",\n")
	s = append(s, "Matchentryinfo: "+fmt.Sprintf("%#v", this.Matchentryinfo)+",\n")
	s = append(s, "Sname: "+fmt.Sprintf("%#v", this.Sname)+",\n")
	s = append(s, "Gamename: "+fmt.Sprintf("%#v", this.Gamename)+",\n")
	s = append(s, "Advicon: "+fmt.Sprintf("%#v", this.Advicon)+",\n")
	s = append(s, "Maxawardpool: "+fmt.Sprintf("%#v", this.Maxawardpool)+",\n")
	s = append(s, "Mclabel: "+fmt.Sprintf("%#v", this.Mclabel)+",\n")
	s = append(s, "Allapplynum: "+fmt.Sprintf("%#v", this.Allapplynum)+",\n")
	s = append(s, "AllFreeTimes: "+fmt.Sprintf("%#v", this.AllFreeTimes)+",\n")
	s = append(s, "FreeTimes: "+fmt.Sprintf("%#v", this.FreeTimes)+",\n")
	keysForMoneylimit := make([]string, 0, len(this.Moneylimit))
	for k, _ := range this.Moneylimit {
		keysForMoneylimit = append(keysForMoneylimit, k)
	}
	sortkeys.Strings(keysForMoneylimit)
	mapStringForMoneylimit := "map[string]string{"
	for _, k := range keysForMoneylimit {
		mapStringForMoneylimit += fmt.Sprintf("%#v: %#v,", k, this.Moneylimit[k])
	}
	mapStringForMoneylimit += "}"
	if this.Moneylimit != nil {
		s = append(s, "Moneylimit: "+mapStringForMoneylimit+",\n")
	}
	s = append(s, "Recommendmatchcfgid: "+fmt.Sprintf("%#v", this.Recommendmatchcfgid)+",\n")
	s = append(s, "Endtime: "+fmt.Sprintf("%#v", this.Endtime)+",\n")
	s = append(s, "Matchpartitions: "+fmt.Sprintf("%#v", this.Matchpartitions)+",\n")
	s = append(s, "Isfhmatch: "+fmt.Sprintf("%#v", this.Isfhmatch)+",\n")
	s = append(s, "Loopintervaltime: "+fmt.Sprintf("%#v", this.Loopintervaltime)+",\n")
	s = append(s, "Firstbegintime: "+fmt.Sprintf("%#v", this.Firstbegintime)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Fee) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&RPCProto.Fee{")
	if this.Subfee != nil {
		vs := make([]*SubFee, len(this.Subfee))
		for i := range vs {
			vs[i] = &this.Subfee[i]
		}
		s = append(s, "Subfee: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SubFee) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&RPCProto.SubFee{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Num: "+fmt.Sprintf("%#v", this.Num)+",\n")
	s = append(s, "Desc: "+fmt.Sprintf("%#v", this.Desc)+",\n")
	s = append(s, "Label: "+fmt.Sprintf("%#v", this.Label)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMatchLists(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *MatchListsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchListsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Cmd))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.App))
	dAtA[i] = 0x18
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.GameId))
	dAtA[i] = 0x20
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Mid))
	dAtA[i] = 0x2a
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Ssid)))
	i += copy(dAtA[i:], m.Ssid)
	dAtA[i] = 0x32
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Action)))
	i += copy(dAtA[i:], m.Action)
	dAtA[i] = 0x38
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Page))
	dAtA[i] = 0x40
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Timestamp))
	dAtA[i] = 0x48
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Seq))
	if len(m.Ids) > 0 {
		for _, msg := range m.Ids {
			dAtA[i] = 0x52
			i++
			i = encodeVarintMatchLists(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x58
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.HallVersion))
	dAtA[i] = 0x60
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.AreaId))
	dAtA[i] = 0x68
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.IsNew))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Id) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Id) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x18
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Configid))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MatchListsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchListsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Tpage))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Srvtime))
	if len(m.List) > 0 {
		for k, _ := range m.List {
			dAtA[i] = 0x1a
			i++
			v := m.List[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovMatchLists(uint64(msgSize))
			}
			mapSize := 1 + sovMatchLists(uint64(k)) + msgSize
			i = encodeVarintMatchLists(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMatchLists(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintMatchLists(dAtA, i, uint64((&v).Size()))
			n1, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n1
		}
	}
	dAtA[i] = 0x20
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Filter))
	dAtA[i] = 0x28
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Iconmax))
	dAtA[i] = 0x30
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Pnum))
	if len(m.Apply) > 0 {
		for _, num := range m.Apply {
			dAtA[i] = 0x38
			i++
			i = encodeVarintMatchLists(dAtA, i, uint64(num))
		}
	}
	if len(m.Delete) > 0 {
		for _, msg := range m.Delete {
			dAtA[i] = 0x42
			i++
			i = encodeVarintMatchLists(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Update) > 0 {
		for _, msg := range m.Update {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintMatchLists(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MatchIcons) > 0 {
		for k, _ := range m.MatchIcons {
			dAtA[i] = 0x52
			i++
			v := m.MatchIcons[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovMatchLists(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovMatchLists(uint64(len(k))) + msgSize
			i = encodeVarintMatchLists(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatchLists(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMatchLists(dAtA, i, uint64((&v).Size()))
			n2, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n2
		}
	}
	if len(m.Sort) > 0 {
		for k, _ := range m.Sort {
			dAtA[i] = 0x5a
			i++
			v := m.Sort[k]
			mapSize := 1 + len(k) + sovMatchLists(uint64(len(k))) + 1 + sovMatchLists(uint64(v))
			i = encodeVarintMatchLists(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatchLists(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintMatchLists(dAtA, i, uint64(v))
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Delete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Delete) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x18
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Configid))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Update) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Update) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x18
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Configid))
	dAtA[i] = 0x20
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Applynum))
	dAtA[i] = 0x28
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Allapplynum))
	dAtA[i] = 0x30
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Stime))
	dAtA[i] = 0x38
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Etime))
	dAtA[i] = 0x40
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Status))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MatchIcon) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchIcon) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Icon)))
	i += copy(dAtA[i:], m.Icon)
	dAtA[i] = 0x12
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Color)))
	i += copy(dAtA[i:], m.Color)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *List) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Mname)))
	i += copy(dAtA[i:], m.Mname)
	dAtA[i] = 0x22
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Micon)))
	i += copy(dAtA[i:], m.Micon)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Iconweight)))
	i += copy(dAtA[i:], m.Iconweight)
	dAtA[i] = 0x32
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.AdIcon)))
	i += copy(dAtA[i:], m.AdIcon)
	dAtA[i] = 0x3a
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.ListSort)))
	i += copy(dAtA[i:], m.ListSort)
	dAtA[i] = 0x40
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Stime))
	dAtA[i] = 0x48
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Etime))
	dAtA[i] = 0x50
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Gameid))
	dAtA[i] = 0x58
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Gamesort))
	dAtA[i] = 0x60
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Requestnum))
	dAtA[i] = 0x68
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Applynum))
	dAtA[i] = 0x70
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Allowwaittime))
	dAtA[i] = 0x7a
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Champion)))
	i += copy(dAtA[i:], m.Champion)
	if len(m.Fee) > 0 {
		for _, msg := range m.Fee {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMatchLists(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Status))
	dAtA[i] = 0x90
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Looptype))
	dAtA[i] = 0x9d
	i++
	dAtA[i] = 0x1
	i++
	binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Loopinterval))))
	i += 4
	dAtA[i] = 0xa2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Loopendtime)))
	i += copy(dAtA[i:], m.Loopendtime)
	dAtA[i] = 0xaa
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.RewardUrl)))
	i += copy(dAtA[i:], m.RewardUrl)
	dAtA[i] = 0xb2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.RewardDescribe)))
	i += copy(dAtA[i:], m.RewardDescribe)
	dAtA[i] = 0xb9
	i++
	dAtA[i] = 0x1
	i++
	binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.ThresholdType))))
	i += 8
	dAtA[i] = 0xc1
	i++
	dAtA[i] = 0x1
	i++
	binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Threshold))))
	i += 8
	dAtA[i] = 0xc8
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Configid))
	dAtA[i] = 0xd2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Matchtags)))
	i += copy(dAtA[i:], m.Matchtags)
	dAtA[i] = 0xda
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Matchentrycode)))
	i += copy(dAtA[i:], m.Matchentrycode)
	dAtA[i] = 0xe2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Matchentryinfo)))
	i += copy(dAtA[i:], m.Matchentryinfo)
	dAtA[i] = 0xea
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Sname)))
	i += copy(dAtA[i:], m.Sname)
	dAtA[i] = 0xf2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Gamename)))
	i += copy(dAtA[i:], m.Gamename)
	dAtA[i] = 0xfa
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Advicon)))
	i += copy(dAtA[i:], m.Advicon)
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Maxawardpool))
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Mclabel)))
	i += copy(dAtA[i:], m.Mclabel)
	dAtA[i] = 0x90
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Allapplynum))
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.AllFreeTimes))
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.FreeTimes))
	if len(m.Moneylimit) > 0 {
		for k, _ := range m.Moneylimit {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x2
			i++
			v := m.Moneylimit[k]
			mapSize := 1 + len(k) + sovMatchLists(uint64(len(k))) + 1 + len(v) + sovMatchLists(uint64(len(v)))
			i = encodeVarintMatchLists(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatchLists(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMatchLists(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	dAtA[i] = 0xb0
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Recommendmatchcfgid))
	dAtA[i] = 0xb8
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Endtime))
	dAtA[i] = 0xc0
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Matchpartitions))
	dAtA[i] = 0xc8
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Isfhmatch))
	dAtA[i] = 0xd0
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Loopintervaltime))
	dAtA[i] = 0xd8
	i++
	dAtA[i] = 0x2
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Firstbegintime))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Fee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fee) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Subfee) > 0 {
		for _, msg := range m.Subfee {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMatchLists(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SubFee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubFee) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x10
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Num))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(len(m.Desc)))
	i += copy(dAtA[i:], m.Desc)
	dAtA[i] = 0x20
	i++
	i = encodeVarintMatchLists(dAtA, i, uint64(m.Label))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMatchLists(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedMatchListsRequest(r randyMatchLists, easy bool) *MatchListsRequest {
	this := &MatchListsRequest{}
	this.Cmd = uint64(uint64(r.Uint32()))
	this.App = uint64(uint64(r.Uint32()))
	this.GameId = uint64(uint64(r.Uint32()))
	this.Mid = uint64(uint64(r.Uint32()))
	this.Ssid = string(randStringMatchLists(r))
	this.Action = string(randStringMatchLists(r))
	this.Page = uint32(r.Uint32())
	this.Timestamp = uint64(uint64(r.Uint32()))
	this.Seq = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v1 := r.Intn(5)
		this.Ids = make([]Id, v1)
		for i := 0; i < v1; i++ {
			v2 := NewPopulatedId(r, easy)
			this.Ids[i] = *v2
		}
	}
	this.HallVersion = uint32(r.Uint32())
	this.AreaId = uint32(r.Uint32())
	this.IsNew = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatchLists(r, 14)
	}
	return this
}

func NewPopulatedId(r randyMatchLists, easy bool) *Id {
	this := &Id{}
	this.Type = uint32(r.Uint32())
	this.Id = uint64(uint64(r.Uint32()))
	this.Configid = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatchLists(r, 4)
	}
	return this
}

func NewPopulatedMatchListsResponse(r randyMatchLists, easy bool) *MatchListsResponse {
	this := &MatchListsResponse{}
	this.Tpage = uint64(uint64(r.Uint32()))
	this.Srvtime = uint64(uint64(r.Uint32()))
	if r.Intn(10) != 0 {
		v3 := r.Intn(10)
		this.List = make(map[uint32]List)
		for i := 0; i < v3; i++ {
			this.List[uint32(r.Uint32())] = *NewPopulatedList(r, easy)
		}
	}
	this.Filter = uint32(r.Uint32())
	this.Iconmax = uint32(r.Uint32())
	this.Pnum = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v4 := r.Intn(10)
		this.Apply = make([]uint64, v4)
		for i := 0; i < v4; i++ {
			this.Apply[i] = uint64(uint64(r.Uint32()))
		}
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(5)
		this.Delete = make([]Delete, v5)
		for i := 0; i < v5; i++ {
			v6 := NewPopulatedDelete(r, easy)
			this.Delete[i] = *v6
		}
	}
	if r.Intn(10) != 0 {
		v7 := r.Intn(5)
		this.Update = make([]Update, v7)
		for i := 0; i < v7; i++ {
			v8 := NewPopulatedUpdate(r, easy)
			this.Update[i] = *v8
		}
	}
	if r.Intn(10) != 0 {
		v9 := r.Intn(10)
		this.MatchIcons = make(map[string]MatchIcon)
		for i := 0; i < v9; i++ {
			this.MatchIcons[randStringMatchLists(r)] = *NewPopulatedMatchIcon(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v10 := r.Intn(10)
		this.Sort = make(map[string]uint32)
		for i := 0; i < v10; i++ {
			v11 := randStringMatchLists(r)
			this.Sort[v11] = uint32(r.Uint32())
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatchLists(r, 12)
	}
	return this
}

func NewPopulatedDelete(r randyMatchLists, easy bool) *Delete {
	this := &Delete{}
	this.Id = uint64(uint64(r.Uint32()))
	this.Type = uint32(r.Uint32())
	this.Configid = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatchLists(r, 4)
	}
	return this
}

func NewPopulatedUpdate(r randyMatchLists, easy bool) *Update {
	this := &Update{}
	this.Id = uint64(uint64(r.Uint32()))
	this.Type = uint32(r.Uint32())
	this.Configid = uint64(uint64(r.Uint32()))
	this.Applynum = uint64(uint64(r.Uint32()))
	this.Allapplynum = uint64(uint64(r.Uint32()))
	this.Stime = uint64(uint64(r.Uint32()))
	this.Etime = uint64(uint64(r.Uint32()))
	this.Status = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatchLists(r, 9)
	}
	return this
}

func NewPopulatedMatchIcon(r randyMatchLists, easy bool) *MatchIcon {
	this := &MatchIcon{}
	this.Icon = string(randStringMatchLists(r))
	this.Color = string(randStringMatchLists(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatchLists(r, 3)
	}
	return this
}

func NewPopulatedList(r randyMatchLists, easy bool) *List {
	this := &List{}
	this.Id = uint64(uint64(r.Uint32()))
	this.Type = uint32(r.Uint32())
	this.Mname = string(randStringMatchLists(r))
	this.Micon = string(randStringMatchLists(r))
	this.Iconweight = string(randStringMatchLists(r))
	this.AdIcon = string(randStringMatchLists(r))
	this.ListSort = string(randStringMatchLists(r))
	this.Stime = uint64(uint64(r.Uint32()))
	this.Etime = uint64(uint64(r.Uint32()))
	this.Gameid = uint64(uint64(r.Uint32()))
	this.Gamesort = uint64(uint64(r.Uint32()))
	this.Requestnum = uint64(uint64(r.Uint32()))
	this.Applynum = uint64(uint64(r.Uint32()))
	this.Allowwaittime = uint32(r.Uint32())
	this.Champion = string(randStringMatchLists(r))
	if r.Intn(10) != 0 {
		v12 := r.Intn(5)
		this.Fee = make([]Fee, v12)
		for i := 0; i < v12; i++ {
			v13 := NewPopulatedFee(r, easy)
			this.Fee[i] = *v13
		}
	}
	this.Status = uint32(r.Uint32())
	this.Looptype = uint32(r.Uint32())
	this.Loopinterval = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.Loopinterval *= -1
	}
	this.Loopendtime = string(randStringMatchLists(r))
	this.RewardUrl = string(randStringMatchLists(r))
	this.RewardDescribe = string(randStringMatchLists(r))
	this.ThresholdType = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.ThresholdType *= -1
	}
	this.Threshold = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Threshold *= -1
	}
	this.Configid = uint64(uint64(r.Uint32()))
	this.Matchtags = string(randStringMatchLists(r))
	this.Matchentrycode = string(randStringMatchLists(r))
	this.Matchentryinfo = string(randStringMatchLists(r))
	this.Sname = string(randStringMatchLists(r))
	this.Gamename = string(randStringMatchLists(r))
	this.Advicon = string(randStringMatchLists(r))
	this.Maxawardpool = uint32(r.Uint32())
	this.Mclabel = string(randStringMatchLists(r))
	this.Allapplynum = uint64(uint64(r.Uint32()))
	this.AllFreeTimes = uint32(r.Uint32())
	this.FreeTimes = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v14 := r.Intn(10)
		this.Moneylimit = make(map[string]string)
		for i := 0; i < v14; i++ {
			this.Moneylimit[randStringMatchLists(r)] = randStringMatchLists(r)
		}
	}
	this.Recommendmatchcfgid = uint64(uint64(r.Uint32()))
	this.Endtime = uint64(uint64(r.Uint32()))
	this.Matchpartitions = uint64(uint64(r.Uint32()))
	this.Isfhmatch = uint32(r.Uint32())
	this.Loopintervaltime = uint64(uint64(r.Uint32()))
	this.Firstbegintime = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatchLists(r, 44)
	}
	return this
}

func NewPopulatedFee(r randyMatchLists, easy bool) *Fee {
	this := &Fee{}
	if r.Intn(10) != 0 {
		v15 := r.Intn(5)
		this.Subfee = make([]SubFee, v15)
		for i := 0; i < v15; i++ {
			v16 := NewPopulatedSubFee(r, easy)
			this.Subfee[i] = *v16
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatchLists(r, 2)
	}
	return this
}

func NewPopulatedSubFee(r randyMatchLists, easy bool) *SubFee {
	this := &SubFee{}
	this.Type = uint32(r.Uint32())
	this.Num = uint64(uint64(r.Uint32()))
	this.Desc = string(randStringMatchLists(r))
	this.Label = uint32(r.Uint32())
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedMatchLists(r, 5)
	}
	return this
}

type randyMatchLists interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneMatchLists(r randyMatchLists) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringMatchLists(r randyMatchLists) string {
	v17 := r.Intn(100)
	tmps := make([]rune, v17)
	for i := 0; i < v17; i++ {
		tmps[i] = randUTF8RuneMatchLists(r)
	}
	return string(tmps)
}
func randUnrecognizedMatchLists(r randyMatchLists, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldMatchLists(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldMatchLists(dAtA []byte, r randyMatchLists, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulateMatchLists(dAtA, uint64(key))
		v18 := r.Int63()
		if r.Intn(2) == 0 {
			v18 *= -1
		}
		dAtA = encodeVarintPopulateMatchLists(dAtA, uint64(v18))
	case 1:
		dAtA = encodeVarintPopulateMatchLists(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulateMatchLists(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulateMatchLists(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulateMatchLists(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulateMatchLists(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *MatchListsRequest) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMatchLists(uint64(m.Cmd))
	n += 1 + sovMatchLists(uint64(m.App))
	n += 1 + sovMatchLists(uint64(m.GameId))
	n += 1 + sovMatchLists(uint64(m.Mid))
	l = len(m.Ssid)
	n += 1 + l + sovMatchLists(uint64(l))
	l = len(m.Action)
	n += 1 + l + sovMatchLists(uint64(l))
	n += 1 + sovMatchLists(uint64(m.Page))
	n += 1 + sovMatchLists(uint64(m.Timestamp))
	n += 1 + sovMatchLists(uint64(m.Seq))
	if len(m.Ids) > 0 {
		for _, e := range m.Ids {
			l = e.Size()
			n += 1 + l + sovMatchLists(uint64(l))
		}
	}
	n += 1 + sovMatchLists(uint64(m.HallVersion))
	n += 1 + sovMatchLists(uint64(m.AreaId))
	n += 1 + sovMatchLists(uint64(m.IsNew))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Id) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMatchLists(uint64(m.Type))
	n += 1 + sovMatchLists(uint64(m.Id))
	n += 1 + sovMatchLists(uint64(m.Configid))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchListsResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMatchLists(uint64(m.Tpage))
	n += 1 + sovMatchLists(uint64(m.Srvtime))
	if len(m.List) > 0 {
		for k, v := range m.List {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovMatchLists(uint64(k)) + 1 + l + sovMatchLists(uint64(l))
			n += mapEntrySize + 1 + sovMatchLists(uint64(mapEntrySize))
		}
	}
	n += 1 + sovMatchLists(uint64(m.Filter))
	n += 1 + sovMatchLists(uint64(m.Iconmax))
	n += 1 + sovMatchLists(uint64(m.Pnum))
	if len(m.Apply) > 0 {
		for _, e := range m.Apply {
			n += 1 + sovMatchLists(uint64(e))
		}
	}
	if len(m.Delete) > 0 {
		for _, e := range m.Delete {
			l = e.Size()
			n += 1 + l + sovMatchLists(uint64(l))
		}
	}
	if len(m.Update) > 0 {
		for _, e := range m.Update {
			l = e.Size()
			n += 1 + l + sovMatchLists(uint64(l))
		}
	}
	if len(m.MatchIcons) > 0 {
		for k, v := range m.MatchIcons {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + len(k) + sovMatchLists(uint64(len(k))) + 1 + l + sovMatchLists(uint64(l))
			n += mapEntrySize + 1 + sovMatchLists(uint64(mapEntrySize))
		}
	}
	if len(m.Sort) > 0 {
		for k, v := range m.Sort {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMatchLists(uint64(len(k))) + 1 + sovMatchLists(uint64(v))
			n += mapEntrySize + 1 + sovMatchLists(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Delete) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMatchLists(uint64(m.Id))
	n += 1 + sovMatchLists(uint64(m.Type))
	n += 1 + sovMatchLists(uint64(m.Configid))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Update) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMatchLists(uint64(m.Id))
	n += 1 + sovMatchLists(uint64(m.Type))
	n += 1 + sovMatchLists(uint64(m.Configid))
	n += 1 + sovMatchLists(uint64(m.Applynum))
	n += 1 + sovMatchLists(uint64(m.Allapplynum))
	n += 1 + sovMatchLists(uint64(m.Stime))
	n += 1 + sovMatchLists(uint64(m.Etime))
	n += 1 + sovMatchLists(uint64(m.Status))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MatchIcon) Size() (n int) {
	var l int
	_ = l
	l = len(m.Icon)
	n += 1 + l + sovMatchLists(uint64(l))
	l = len(m.Color)
	n += 1 + l + sovMatchLists(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *List) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMatchLists(uint64(m.Id))
	n += 1 + sovMatchLists(uint64(m.Type))
	l = len(m.Mname)
	n += 1 + l + sovMatchLists(uint64(l))
	l = len(m.Micon)
	n += 1 + l + sovMatchLists(uint64(l))
	l = len(m.Iconweight)
	n += 1 + l + sovMatchLists(uint64(l))
	l = len(m.AdIcon)
	n += 1 + l + sovMatchLists(uint64(l))
	l = len(m.ListSort)
	n += 1 + l + sovMatchLists(uint64(l))
	n += 1 + sovMatchLists(uint64(m.Stime))
	n += 1 + sovMatchLists(uint64(m.Etime))
	n += 1 + sovMatchLists(uint64(m.Gameid))
	n += 1 + sovMatchLists(uint64(m.Gamesort))
	n += 1 + sovMatchLists(uint64(m.Requestnum))
	n += 1 + sovMatchLists(uint64(m.Applynum))
	n += 1 + sovMatchLists(uint64(m.Allowwaittime))
	l = len(m.Champion)
	n += 1 + l + sovMatchLists(uint64(l))
	if len(m.Fee) > 0 {
		for _, e := range m.Fee {
			l = e.Size()
			n += 2 + l + sovMatchLists(uint64(l))
		}
	}
	n += 2 + sovMatchLists(uint64(m.Status))
	n += 2 + sovMatchLists(uint64(m.Looptype))
	n += 6
	l = len(m.Loopendtime)
	n += 2 + l + sovMatchLists(uint64(l))
	l = len(m.RewardUrl)
	n += 2 + l + sovMatchLists(uint64(l))
	l = len(m.RewardDescribe)
	n += 2 + l + sovMatchLists(uint64(l))
	n += 10
	n += 10
	n += 2 + sovMatchLists(uint64(m.Configid))
	l = len(m.Matchtags)
	n += 2 + l + sovMatchLists(uint64(l))
	l = len(m.Matchentrycode)
	n += 2 + l + sovMatchLists(uint64(l))
	l = len(m.Matchentryinfo)
	n += 2 + l + sovMatchLists(uint64(l))
	l = len(m.Sname)
	n += 2 + l + sovMatchLists(uint64(l))
	l = len(m.Gamename)
	n += 2 + l + sovMatchLists(uint64(l))
	l = len(m.Advicon)
	n += 2 + l + sovMatchLists(uint64(l))
	n += 2 + sovMatchLists(uint64(m.Maxawardpool))
	l = len(m.Mclabel)
	n += 2 + l + sovMatchLists(uint64(l))
	n += 2 + sovMatchLists(uint64(m.Allapplynum))
	n += 2 + sovMatchLists(uint64(m.AllFreeTimes))
	n += 2 + sovMatchLists(uint64(m.FreeTimes))
	if len(m.Moneylimit) > 0 {
		for k, v := range m.Moneylimit {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMatchLists(uint64(len(k))) + 1 + len(v) + sovMatchLists(uint64(len(v)))
			n += mapEntrySize + 2 + sovMatchLists(uint64(mapEntrySize))
		}
	}
	n += 2 + sovMatchLists(uint64(m.Recommendmatchcfgid))
	n += 2 + sovMatchLists(uint64(m.Endtime))
	n += 2 + sovMatchLists(uint64(m.Matchpartitions))
	n += 2 + sovMatchLists(uint64(m.Isfhmatch))
	n += 2 + sovMatchLists(uint64(m.Loopintervaltime))
	n += 2 + sovMatchLists(uint64(m.Firstbegintime))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Fee) Size() (n int) {
	var l int
	_ = l
	if len(m.Subfee) > 0 {
		for _, e := range m.Subfee {
			l = e.Size()
			n += 1 + l + sovMatchLists(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubFee) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovMatchLists(uint64(m.Type))
	n += 1 + sovMatchLists(uint64(m.Num))
	l = len(m.Desc)
	n += 1 + l + sovMatchLists(uint64(l))
	n += 1 + sovMatchLists(uint64(m.Label))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMatchLists(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMatchLists(x uint64) (n int) {
	return sovMatchLists(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *MatchListsRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchListsRequest{`,
		`Cmd:` + fmt.Sprintf("%v", this.Cmd) + `,`,
		`App:` + fmt.Sprintf("%v", this.App) + `,`,
		`GameId:` + fmt.Sprintf("%v", this.GameId) + `,`,
		`Mid:` + fmt.Sprintf("%v", this.Mid) + `,`,
		`Ssid:` + fmt.Sprintf("%v", this.Ssid) + `,`,
		`Action:` + fmt.Sprintf("%v", this.Action) + `,`,
		`Page:` + fmt.Sprintf("%v", this.Page) + `,`,
		`Timestamp:` + fmt.Sprintf("%v", this.Timestamp) + `,`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`Ids:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Ids), "Id", "Id", 1), `&`, ``, 1) + `,`,
		`HallVersion:` + fmt.Sprintf("%v", this.HallVersion) + `,`,
		`AreaId:` + fmt.Sprintf("%v", this.AreaId) + `,`,
		`IsNew:` + fmt.Sprintf("%v", this.IsNew) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Id) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Id{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Configid:` + fmt.Sprintf("%v", this.Configid) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchListsResponse) String() string {
	if this == nil {
		return "nil"
	}
	keysForList := make([]uint32, 0, len(this.List))
	for k, _ := range this.List {
		keysForList = append(keysForList, k)
	}
	sortkeys.Uint32s(keysForList)
	mapStringForList := "map[uint32]List{"
	for _, k := range keysForList {
		mapStringForList += fmt.Sprintf("%v: %v,", k, this.List[k])
	}
	mapStringForList += "}"
	keysForMatchIcons := make([]string, 0, len(this.MatchIcons))
	for k, _ := range this.MatchIcons {
		keysForMatchIcons = append(keysForMatchIcons, k)
	}
	sortkeys.Strings(keysForMatchIcons)
	mapStringForMatchIcons := "map[string]MatchIcon{"
	for _, k := range keysForMatchIcons {
		mapStringForMatchIcons += fmt.Sprintf("%v: %v,", k, this.MatchIcons[k])
	}
	mapStringForMatchIcons += "}"
	keysForSort := make([]string, 0, len(this.Sort))
	for k, _ := range this.Sort {
		keysForSort = append(keysForSort, k)
	}
	sortkeys.Strings(keysForSort)
	mapStringForSort := "map[string]uint32{"
	for _, k := range keysForSort {
		mapStringForSort += fmt.Sprintf("%v: %v,", k, this.Sort[k])
	}
	mapStringForSort += "}"
	s := strings.Join([]string{`&MatchListsResponse{`,
		`Tpage:` + fmt.Sprintf("%v", this.Tpage) + `,`,
		`Srvtime:` + fmt.Sprintf("%v", this.Srvtime) + `,`,
		`List:` + mapStringForList + `,`,
		`Filter:` + fmt.Sprintf("%v", this.Filter) + `,`,
		`Iconmax:` + fmt.Sprintf("%v", this.Iconmax) + `,`,
		`Pnum:` + fmt.Sprintf("%v", this.Pnum) + `,`,
		`Apply:` + fmt.Sprintf("%v", this.Apply) + `,`,
		`Delete:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Delete), "Delete", "Delete", 1), `&`, ``, 1) + `,`,
		`Update:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Update), "Update", "Update", 1), `&`, ``, 1) + `,`,
		`MatchIcons:` + mapStringForMatchIcons + `,`,
		`Sort:` + mapStringForSort + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Delete) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Delete{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Configid:` + fmt.Sprintf("%v", this.Configid) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Update) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Update{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Configid:` + fmt.Sprintf("%v", this.Configid) + `,`,
		`Applynum:` + fmt.Sprintf("%v", this.Applynum) + `,`,
		`Allapplynum:` + fmt.Sprintf("%v", this.Allapplynum) + `,`,
		`Stime:` + fmt.Sprintf("%v", this.Stime) + `,`,
		`Etime:` + fmt.Sprintf("%v", this.Etime) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MatchIcon) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MatchIcon{`,
		`Icon:` + fmt.Sprintf("%v", this.Icon) + `,`,
		`Color:` + fmt.Sprintf("%v", this.Color) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *List) String() string {
	if this == nil {
		return "nil"
	}
	keysForMoneylimit := make([]string, 0, len(this.Moneylimit))
	for k, _ := range this.Moneylimit {
		keysForMoneylimit = append(keysForMoneylimit, k)
	}
	sortkeys.Strings(keysForMoneylimit)
	mapStringForMoneylimit := "map[string]string{"
	for _, k := range keysForMoneylimit {
		mapStringForMoneylimit += fmt.Sprintf("%v: %v,", k, this.Moneylimit[k])
	}
	mapStringForMoneylimit += "}"
	s := strings.Join([]string{`&List{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Mname:` + fmt.Sprintf("%v", this.Mname) + `,`,
		`Micon:` + fmt.Sprintf("%v", this.Micon) + `,`,
		`Iconweight:` + fmt.Sprintf("%v", this.Iconweight) + `,`,
		`AdIcon:` + fmt.Sprintf("%v", this.AdIcon) + `,`,
		`ListSort:` + fmt.Sprintf("%v", this.ListSort) + `,`,
		`Stime:` + fmt.Sprintf("%v", this.Stime) + `,`,
		`Etime:` + fmt.Sprintf("%v", this.Etime) + `,`,
		`Gameid:` + fmt.Sprintf("%v", this.Gameid) + `,`,
		`Gamesort:` + fmt.Sprintf("%v", this.Gamesort) + `,`,
		`Requestnum:` + fmt.Sprintf("%v", this.Requestnum) + `,`,
		`Applynum:` + fmt.Sprintf("%v", this.Applynum) + `,`,
		`Allowwaittime:` + fmt.Sprintf("%v", this.Allowwaittime) + `,`,
		`Champion:` + fmt.Sprintf("%v", this.Champion) + `,`,
		`Fee:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Fee), "Fee", "Fee", 1), `&`, ``, 1) + `,`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Looptype:` + fmt.Sprintf("%v", this.Looptype) + `,`,
		`Loopinterval:` + fmt.Sprintf("%v", this.Loopinterval) + `,`,
		`Loopendtime:` + fmt.Sprintf("%v", this.Loopendtime) + `,`,
		`RewardUrl:` + fmt.Sprintf("%v", this.RewardUrl) + `,`,
		`RewardDescribe:` + fmt.Sprintf("%v", this.RewardDescribe) + `,`,
		`ThresholdType:` + fmt.Sprintf("%v", this.ThresholdType) + `,`,
		`Threshold:` + fmt.Sprintf("%v", this.Threshold) + `,`,
		`Configid:` + fmt.Sprintf("%v", this.Configid) + `,`,
		`Matchtags:` + fmt.Sprintf("%v", this.Matchtags) + `,`,
		`Matchentrycode:` + fmt.Sprintf("%v", this.Matchentrycode) + `,`,
		`Matchentryinfo:` + fmt.Sprintf("%v", this.Matchentryinfo) + `,`,
		`Sname:` + fmt.Sprintf("%v", this.Sname) + `,`,
		`Gamename:` + fmt.Sprintf("%v", this.Gamename) + `,`,
		`Advicon:` + fmt.Sprintf("%v", this.Advicon) + `,`,
		`Maxawardpool:` + fmt.Sprintf("%v", this.Maxawardpool) + `,`,
		`Mclabel:` + fmt.Sprintf("%v", this.Mclabel) + `,`,
		`Allapplynum:` + fmt.Sprintf("%v", this.Allapplynum) + `,`,
		`AllFreeTimes:` + fmt.Sprintf("%v", this.AllFreeTimes) + `,`,
		`FreeTimes:` + fmt.Sprintf("%v", this.FreeTimes) + `,`,
		`Moneylimit:` + mapStringForMoneylimit + `,`,
		`Recommendmatchcfgid:` + fmt.Sprintf("%v", this.Recommendmatchcfgid) + `,`,
		`Endtime:` + fmt.Sprintf("%v", this.Endtime) + `,`,
		`Matchpartitions:` + fmt.Sprintf("%v", this.Matchpartitions) + `,`,
		`Isfhmatch:` + fmt.Sprintf("%v", this.Isfhmatch) + `,`,
		`Loopintervaltime:` + fmt.Sprintf("%v", this.Loopintervaltime) + `,`,
		`Firstbegintime:` + fmt.Sprintf("%v", this.Firstbegintime) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Fee) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Fee{`,
		`Subfee:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Subfee), "SubFee", "SubFee", 1), `&`, ``, 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SubFee) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SubFee{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Num:` + fmt.Sprintf("%v", this.Num) + `,`,
		`Desc:` + fmt.Sprintf("%v", this.Desc) + `,`,
		`Label:` + fmt.Sprintf("%v", this.Label) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMatchLists(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *MatchListsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatchLists
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchListsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchListsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			m.App = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.App |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			m.GameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GameId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ssid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ssid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ids = append(m.Ids, Id{})
			if err := m.Ids[len(m.Ids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HallVersion", wireType)
			}
			m.HallVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HallVersion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaId", wireType)
			}
			m.AreaId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNew", wireType)
			}
			m.IsNew = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsNew |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatchLists(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatchLists
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Id) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatchLists
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Id: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Id: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configid", wireType)
			}
			m.Configid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Configid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatchLists(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatchLists
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchListsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatchLists
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchListsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchListsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tpage", wireType)
			}
			m.Tpage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tpage |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Srvtime", wireType)
			}
			m.Srvtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Srvtime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.List == nil {
				m.List = make(map[uint32]List)
			}
			var mapkey uint32
			mapvalue := &List{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatchLists
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatchLists
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatchLists
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMatchLists
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMatchLists
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &List{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMatchLists(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMatchLists
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.List[mapkey] = *mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			m.Filter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Filter |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iconmax", wireType)
			}
			m.Iconmax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Iconmax |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pnum", wireType)
			}
			m.Pnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pnum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatchLists
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Apply = append(m.Apply, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatchLists
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMatchLists
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatchLists
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Apply = append(m.Apply, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Apply", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Delete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Delete = append(m.Delete, Delete{})
			if err := m.Delete[len(m.Delete)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Update = append(m.Update, Update{})
			if err := m.Update[len(m.Update)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchIcons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MatchIcons == nil {
				m.MatchIcons = make(map[string]MatchIcon)
			}
			var mapkey string
			mapvalue := &MatchIcon{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatchLists
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatchLists
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMatchLists
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatchLists
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMatchLists
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthMatchLists
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MatchIcon{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMatchLists(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMatchLists
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.MatchIcons[mapkey] = *mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sort == nil {
				m.Sort = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatchLists
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatchLists
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMatchLists
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatchLists
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMatchLists(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMatchLists
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sort[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatchLists(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatchLists
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Delete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatchLists
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Delete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Delete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configid", wireType)
			}
			m.Configid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Configid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatchLists(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatchLists
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Update) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatchLists
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Update: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Update: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configid", wireType)
			}
			m.Configid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Configid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applynum", wireType)
			}
			m.Applynum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Applynum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allapplynum", wireType)
			}
			m.Allapplynum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Allapplynum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stime", wireType)
			}
			m.Stime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etime", wireType)
			}
			m.Etime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Etime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatchLists(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatchLists
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchIcon) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatchLists
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchIcon: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchIcon: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Color = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatchLists(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatchLists
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatchLists
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Micon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Micon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iconweight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Iconweight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ListSort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ListSort = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stime", wireType)
			}
			m.Stime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Etime", wireType)
			}
			m.Etime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Etime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gameid", wireType)
			}
			m.Gameid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gameid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gamesort", wireType)
			}
			m.Gamesort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gamesort |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requestnum", wireType)
			}
			m.Requestnum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Requestnum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applynum", wireType)
			}
			m.Applynum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Applynum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allowwaittime", wireType)
			}
			m.Allowwaittime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Allowwaittime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Champion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Champion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fee = append(m.Fee, Fee{})
			if err := m.Fee[len(m.Fee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Looptype", wireType)
			}
			m.Looptype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Looptype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loopinterval", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Loopinterval = float32(math.Float32frombits(v))
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loopendtime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Loopendtime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardDescribe", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardDescribe = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdType", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.ThresholdType = float64(math.Float64frombits(v))
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Threshold = float64(math.Float64frombits(v))
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configid", wireType)
			}
			m.Configid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Configid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matchtags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Matchtags = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matchentrycode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Matchentrycode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matchentryinfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Matchentryinfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gamename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gamename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Advicon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Advicon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maxawardpool", wireType)
			}
			m.Maxawardpool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Maxawardpool |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mclabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mclabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allapplynum", wireType)
			}
			m.Allapplynum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Allapplynum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllFreeTimes", wireType)
			}
			m.AllFreeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllFreeTimes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeTimes", wireType)
			}
			m.FreeTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeTimes |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moneylimit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Moneylimit == nil {
				m.Moneylimit = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMatchLists
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatchLists
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMatchLists
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMatchLists
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMatchLists
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMatchLists(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMatchLists
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Moneylimit[mapkey] = mapvalue
			iNdEx = postIndex
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recommendmatchcfgid", wireType)
			}
			m.Recommendmatchcfgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Recommendmatchcfgid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endtime", wireType)
			}
			m.Endtime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Endtime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Matchpartitions", wireType)
			}
			m.Matchpartitions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Matchpartitions |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isfhmatch", wireType)
			}
			m.Isfhmatch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Isfhmatch |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loopintervaltime", wireType)
			}
			m.Loopintervaltime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Loopintervaltime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Firstbegintime", wireType)
			}
			m.Firstbegintime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Firstbegintime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatchLists(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatchLists
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatchLists
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subfee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subfee = append(m.Subfee, SubFee{})
			if err := m.Subfee[len(m.Subfee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMatchLists(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatchLists
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubFee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMatchLists
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubFee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubFee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMatchLists
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			m.Label = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Label |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMatchLists(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMatchLists
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMatchLists(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMatchLists
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMatchLists
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMatchLists
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMatchLists
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMatchLists(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMatchLists = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMatchLists   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("match_lists.proto", fileDescriptorMatchLists) }

var fileDescriptorMatchLists = []byte{
	// 1349 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x4b, 0x8f, 0x1b, 0x45,
	0x17, 0x4d, 0x8f, 0x1f, 0x33, 0xbe, 0x1e, 0x67, 0x26, 0x95, 0xf9, 0xf2, 0x15, 0x26, 0xe9, 0x18,
	0x33, 0x49, 0x9c, 0x10, 0x9c, 0x28, 0x12, 0x0f, 0x21, 0x21, 0x41, 0x08, 0x41, 0x23, 0x11, 0x14,
	0x39, 0x8f, 0x05, 0x9b, 0xa8, 0xec, 0x2e, 0xdb, 0x25, 0xfa, 0x95, 0xae, 0xf6, 0x4c, 0x66, 0xc7,
	0x2f, 0x60, 0xc1, 0x8a, 0x9f, 0xc0, 0x4f, 0x60, 0xc9, 0x32, 0x1b, 0x24, 0x96, 0xac, 0x50, 0xc6,
	0xfc, 0x01, 0x96, 0x88, 0x15, 0xba, 0xb7, 0xdd, 0xed, 0xdb, 0x9e, 0x21, 0x01, 0x89, 0xd5, 0xb8,
	0xcf, 0x39, 0xf5, 0x3a, 0x75, 0x6e, 0x55, 0x0d, 0x9c, 0x09, 0x54, 0x3a, 0x9a, 0x3e, 0xf1, 0x8d,
	0x4d, 0x6d, 0x3f, 0x4e, 0xa2, 0x34, 0x12, 0x1b, 0x83, 0xfb, 0x9f, 0xdc, 0xc7, 0x5f, 0xed, 0xb7,
	0x27, 0x26, 0x9d, 0xce, 0x86, 0xfd, 0x51, 0x14, 0xdc, 0x98, 0x44, 0x93, 0xe8, 0x06, 0x09, 0x86,
	0xb3, 0x31, 0x7d, 0xd1, 0x07, 0xfd, 0xca, 0x1a, 0x76, 0xbf, 0xad, 0xc0, 0x99, 0x7b, 0xd8, 0xdd,
	0xe7, 0xd8, 0xdb, 0x40, 0x3f, 0x9d, 0x69, 0x9b, 0x8a, 0x73, 0x50, 0x19, 0x05, 0x9e, 0x74, 0x3a,
	0x4e, 0xaf, 0x7a, 0xbb, 0xfa, 0xfc, 0xd7, 0x8b, 0xa7, 0x06, 0x08, 0x20, 0xae, 0xe2, 0x58, 0xae,
	0x71, 0x5c, 0xc5, 0xb1, 0xb8, 0x00, 0xeb, 0x13, 0x15, 0xe8, 0x27, 0xc6, 0x93, 0x15, 0xc6, 0xd5,
	0x11, 0xdc, 0xa3, 0x66, 0x81, 0xf1, 0x64, 0x95, 0x37, 0x0b, 0x8c, 0x27, 0x24, 0x54, 0xad, 0x35,
	0x9e, 0xac, 0x75, 0x9c, 0x5e, 0x63, 0x41, 0x10, 0x22, 0xce, 0x43, 0x5d, 0x8d, 0x52, 0x13, 0x85,
	0xb2, 0xce, 0xb8, 0x05, 0x86, 0xed, 0x62, 0x35, 0xd1, 0x72, 0xbd, 0xe3, 0xf4, 0x5a, 0x79, 0x3b,
	0x44, 0x44, 0x17, 0x1a, 0xa9, 0x09, 0xb4, 0x4d, 0x55, 0x10, 0xcb, 0x0d, 0x36, 0xde, 0x12, 0xc6,
	0xd9, 0x58, 0xfd, 0x54, 0x36, 0x58, 0x63, 0x04, 0xc4, 0x2e, 0x54, 0x8c, 0x67, 0x25, 0x74, 0x2a,
	0xbd, 0xe6, 0xad, 0xcd, 0x7e, 0xee, 0x68, 0x7f, 0xcf, 0xcb, 0x55, 0xc6, 0xb3, 0xe2, 0x0a, 0x6c,
	0x4e, 0x95, 0xef, 0x3f, 0xd9, 0xd7, 0x89, 0xc5, 0xf9, 0x35, 0x59, 0x37, 0x4d, 0x64, 0x1e, 0x67,
	0x04, 0x7a, 0xa2, 0x12, 0xad, 0xd0, 0x93, 0x4d, 0xa6, 0xa9, 0x23, 0xb8, 0xe7, 0x89, 0x36, 0xd4,
	0x8c, 0xfd, 0x42, 0x1f, 0xc8, 0x16, 0x23, 0x33, 0xa8, 0xfb, 0x18, 0xd6, 0xf6, 0xc8, 0x9d, 0xf4,
	0x30, 0xd6, 0xb4, 0x0b, 0xc5, 0x2a, 0x11, 0x11, 0x3b, 0xb0, 0x66, 0xbc, 0xd2, 0x2e, 0xac, 0x19,
	0x4f, 0x74, 0x60, 0x63, 0x14, 0x85, 0x63, 0x33, 0x59, 0xd9, 0x85, 0x02, 0xed, 0xfe, 0x54, 0x03,
	0xc1, 0x37, 0xdb, 0xc6, 0x51, 0x68, 0x35, 0x4e, 0x25, 0x25, 0x3f, 0xf9, 0x7e, 0x67, 0x90, 0x70,
	0x61, 0xdd, 0x26, 0xfb, 0x68, 0x5e, 0x69, 0xbc, 0x1c, 0x14, 0x1f, 0x41, 0x15, 0x73, 0x28, 0x2b,
	0xe4, 0xda, 0xe5, 0xa5, 0x6b, 0xc7, 0xc7, 0xe9, 0xe3, 0xd7, 0xa7, 0x61, 0x9a, 0x1c, 0xe6, 0x8b,
	0xc1, 0x96, 0xb8, 0xd5, 0x63, 0xe3, 0xa7, 0x3a, 0xa1, 0x7c, 0x14, 0x36, 0x65, 0x18, 0x8e, 0x6f,
	0x46, 0x51, 0x18, 0xa8, 0x67, 0x94, 0x92, 0x9c, 0xce, 0x41, 0x8a, 0x42, 0x38, 0x0b, 0x28, 0x26,
	0xcb, 0x28, 0x84, 0xb3, 0x40, 0xec, 0x40, 0x4d, 0xc5, 0xb1, 0x7f, 0x28, 0xd7, 0x3b, 0x95, 0x5e,
	0x75, 0x90, 0x7d, 0x88, 0x3e, 0xd4, 0x3d, 0xed, 0xeb, 0x54, 0xcb, 0x0d, 0x9a, 0xf1, 0xf6, 0x72,
	0xc6, 0x77, 0x08, 0xcf, 0xc7, 0xcf, 0x54, 0xa8, 0x9f, 0xc5, 0x9e, 0x4a, 0xb5, 0x6c, 0xac, 0xea,
	0x1f, 0x11, 0x9e, 0xeb, 0x33, 0x95, 0x78, 0x00, 0xcd, 0xac, 0x3a, 0x71, 0x82, 0x79, 0x98, 0xae,
	0xbf, 0xd4, 0x16, 0x82, 0xf6, 0x50, 0xce, 0xcd, 0x81, 0xa0, 0x80, 0xd1, 0x64, 0x1b, 0x25, 0xa9,
	0x6c, 0xfe, 0x03, 0x93, 0x1f, 0x44, 0x49, 0xd9, 0x64, 0x6c, 0xd9, 0xfe, 0x0c, 0x1a, 0x85, 0xfb,
	0x62, 0x1b, 0x2a, 0x5f, 0xe9, 0xc3, 0x2c, 0x57, 0x03, 0xfc, 0x29, 0x76, 0xa1, 0xb6, 0xaf, 0xfc,
	0x59, 0xb6, 0xc7, 0xcd, 0x5b, 0xa7, 0x97, 0x23, 0x60, 0xab, 0x41, 0x46, 0x7e, 0xb0, 0xf6, 0xbe,
	0xd3, 0x1e, 0xc0, 0xd6, 0xca, 0x7c, 0x79, 0x77, 0x8d, 0xac, 0xbb, 0xab, 0xe5, 0xee, 0xce, 0xae,
	0x4c, 0x18, 0xdb, 0xf2, 0x3e, 0xdf, 0x83, 0x46, 0x31, 0xeb, 0x13, 0x7a, 0xdb, 0xe1, 0xbd, 0xb5,
	0x58, 0xc3, 0xee, 0x97, 0x50, 0xcf, 0x36, 0x6d, 0x51, 0x11, 0xce, 0x4a, 0x45, 0xe4, 0x15, 0xb4,
	0x76, 0xac, 0x82, 0x5e, 0x5d, 0x2b, 0x7f, 0x3a, 0x50, 0xcf, 0x76, 0xf8, 0xbf, 0xef, 0x1c, 0x15,
	0x14, 0x47, 0x4c, 0x2e, 0x3f, 0x15, 0x0b, 0x54, 0x5c, 0x86, 0xa6, 0xf2, 0xfd, 0x42, 0x54, 0x63,
	0x22, 0x4e, 0x60, 0xed, 0x5a, 0xaa, 0xce, 0x3a, 0xaf, 0x5d, 0x82, 0x90, 0xd3, 0xc4, 0xad, 0x73,
	0x8e, 0x20, 0xac, 0x3a, 0x9b, 0xaa, 0x74, 0x66, 0xe9, 0x94, 0x2c, 0xaa, 0x2e, 0xc3, 0xba, 0x1f,
	0x43, 0xa3, 0xd8, 0x29, 0x5c, 0x28, 0x86, 0x39, 0xdb, 0x92, 0x7c, 0xa1, 0x88, 0xe0, 0x00, 0xa3,
	0xc8, 0x8f, 0x12, 0xf2, 0x20, 0xa7, 0x32, 0xa8, 0xfb, 0x4d, 0x0b, 0xaa, 0x18, 0x9e, 0x7f, 0xed,
	0x5e, 0x1b, 0x6a, 0x41, 0xa8, 0x02, 0x4d, 0xd6, 0x15, 0x9d, 0x12, 0x44, 0x1c, 0xcd, 0xa5, 0x5a,
	0xe2, 0x68, 0x32, 0xbb, 0x00, 0xf8, 0xf7, 0x40, 0x9b, 0xc9, 0x34, 0x2d, 0x5d, 0x29, 0x0c, 0xa7,
	0x8b, 0xc5, 0xc3, 0x65, 0xad, 0x5c, 0x2c, 0x84, 0xe1, 0xbe, 0xe0, 0x99, 0x84, 0x69, 0x24, 0xd3,
	0x72, 0xbe, 0x40, 0x97, 0x7e, 0x6f, 0xbc, 0xc4, 0xef, 0xc6, 0x89, 0x7e, 0xe3, 0x65, 0x68, 0x3c,
	0x09, 0xab, 0x17, 0x64, 0x96, 0x07, 0xfc, 0xb5, 0x28, 0x72, 0x96, 0x87, 0x1c, 0xc5, 0xd5, 0x25,
	0xd9, 0xe5, 0x8c, 0x71, 0xd8, 0x64, 0x1a, 0x86, 0x97, 0x72, 0xd5, 0x3a, 0x31, 0x57, 0xd7, 0xa0,
	0xa5, 0x7c, 0x3f, 0x3a, 0x38, 0x50, 0x26, 0xa5, 0xb9, 0x9e, 0x66, 0x1b, 0x50, 0xa6, 0x28, 0xc7,
	0x53, 0x15, 0xc4, 0x78, 0xcd, 0x6d, 0x71, 0x37, 0x72, 0x54, 0x5c, 0x82, 0xca, 0x58, 0x6b, 0xb9,
	0x4d, 0xe7, 0x52, 0x6b, 0x59, 0xe6, 0x77, 0x75, 0x7e, 0x2e, 0x22, 0xcf, 0xc2, 0x76, 0xe6, 0x78,
	0xd8, 0xc8, 0xf4, 0x28, 0x8a, 0x29, 0x0e, 0x82, 0xf1, 0x05, 0x2a, 0x7a, 0xb0, 0x89, 0xbf, 0x4d,
	0x98, 0xea, 0x64, 0x5f, 0xf9, 0xf2, 0x6c, 0xc7, 0xe9, 0xad, 0x2d, 0x54, 0x25, 0x06, 0xcb, 0x06,
	0xbf, 0x75, 0xe8, 0xd1, 0xe2, 0x76, 0xd8, 0xac, 0x39, 0x81, 0xef, 0x84, 0x44, 0x1f, 0xa8, 0xc4,
	0x7b, 0x94, 0xf8, 0xf2, 0x7f, 0x4c, 0xb5, 0x84, 0xc5, 0x75, 0x38, 0x9d, 0x7d, 0xdc, 0xd1, 0x76,
	0x94, 0x98, 0xa1, 0x96, 0xe7, 0x98, 0x70, 0x85, 0x43, 0x63, 0xd3, 0x69, 0xa2, 0xed, 0x34, 0xf2,
	0xbd, 0x87, 0xb8, 0x94, 0xff, 0x77, 0x9c, 0x9e, 0x93, 0x1b, 0x5b, 0xa2, 0xe8, 0x95, 0x92, 0x03,
	0x52, 0x32, 0xdd, 0x12, 0x2e, 0x1d, 0x22, 0xaf, 0x9d, 0x78, 0x88, 0x74, 0xa1, 0x41, 0x77, 0x44,
	0xaa, 0x26, 0x56, 0xb6, 0xf9, 0x1a, 0x0a, 0x18, 0xd7, 0x40, 0x1f, 0x1a, 0xcf, 0xd6, 0x51, 0xe4,
	0x69, 0xf9, 0x3a, 0x5f, 0x43, 0x99, 0x2b, 0xab, 0x4d, 0x38, 0x8e, 0xe4, 0xf9, 0x93, 0xd5, 0xc8,
	0x51, 0x29, 0x50, 0xa1, 0x5e, 0xe0, 0xc5, 0x48, 0x50, 0x1e, 0x68, 0xa2, 0x5d, 0x1e, 0x9d, 0x1c,
	0xc5, 0x8b, 0x5d, 0x79, 0xfb, 0x54, 0xcc, 0x17, 0x99, 0x20, 0x07, 0x71, 0xcf, 0x03, 0xf5, 0x4c,
	0xa1, 0xc7, 0x71, 0x14, 0xf9, 0xb2, 0xc3, 0x92, 0x51, 0x62, 0xb0, 0xa7, 0x60, 0xe4, 0xab, 0xa1,
	0xf6, 0xe5, 0x1b, 0xbc, 0xa7, 0x05, 0xb8, 0x7a, 0x94, 0x76, 0xff, 0xee, 0x28, 0xed, 0xc1, 0xa6,
	0xf2, 0xfd, 0xbb, 0x89, 0xd6, 0x0f, 0xf1, 0xad, 0x28, 0xdf, 0xe4, 0x23, 0x72, 0x06, 0x9d, 0x1f,
	0x17, 0xb2, 0x5d, 0x26, 0x5b, 0xc2, 0xe2, 0x0e, 0x40, 0x10, 0x85, 0xfa, 0xd0, 0x37, 0x81, 0x49,
	0xe5, 0x25, 0xaa, 0x10, 0xb7, 0x7c, 0xaf, 0xf6, 0xef, 0x15, 0x82, 0xf2, 0xcd, 0x5f, 0xc0, 0xe2,
	0x5d, 0x38, 0x9b, 0xe8, 0x51, 0x14, 0x04, 0x3a, 0xf4, 0xc8, 0xfe, 0xd1, 0x18, 0x03, 0x71, 0x99,
	0xad, 0xe1, 0x24, 0x01, 0x7a, 0x92, 0xd7, 0xc0, 0x15, 0xfe, 0x6c, 0xcb, 0xf3, 0xdf, 0x87, 0x2d,
	0x52, 0xc7, 0x2a, 0x49, 0x0d, 0xbe, 0xa9, 0xad, 0xec, 0x31, 0xdd, 0x2a, 0x89, 0x2b, 0x36, 0x76,
	0x3c, 0x25, 0x58, 0x5e, 0xe5, 0x2b, 0x2e, 0x60, 0x71, 0x13, 0xb6, 0x79, 0x2d, 0xd2, 0xe0, 0xd7,
	0x58, 0xa7, 0xc7, 0x58, 0xcc, 0xdb, 0xd8, 0x24, 0x36, 0x1d, 0xea, 0x89, 0x09, 0x49, 0xff, 0x16,
	0xd3, 0xaf, 0x70, 0xed, 0x0f, 0x61, 0x6b, 0xc5, 0xb0, 0x57, 0x3d, 0x16, 0x1a, 0xfc, 0xb1, 0xf0,
	0x0e, 0x54, 0xee, 0x6a, 0x7a, 0xd0, 0xd9, 0xd9, 0x10, 0x4f, 0x2d, 0x67, 0xf5, 0x41, 0xf7, 0x60,
	0x36, 0x5c, 0x1e, 0x5c, 0x0b, 0x55, 0x37, 0x86, 0x7a, 0x86, 0xbf, 0xe4, 0x3d, 0x7e, 0x0e, 0x2a,
	0x98, 0xac, 0xd2, 0xbf, 0x45, 0x98, 0x28, 0x09, 0x55, 0x4f, 0xdb, 0x51, 0xe9, 0x26, 0x23, 0x04,
	0x6b, 0x27, 0x4b, 0x2c, 0x7f, 0xf3, 0x66, 0xd0, 0xed, 0x9b, 0xbf, 0x1c, 0xb9, 0xa7, 0x5e, 0x1c,
	0xb9, 0xce, 0xef, 0x47, 0xae, 0xf3, 0xc7, 0x91, 0xeb, 0x7c, 0x3d, 0x77, 0x9d, 0xef, 0xe7, 0xae,
	0xf3, 0xc3, 0xdc, 0x75, 0x7e, 0x9c, 0xbb, 0xce, 0xf3, 0xb9, 0xeb, 0xfc, 0x3c, 0x77, 0x9d, 0x17,
	0x73, 0xd7, 0xf9, 0xee, 0x37, 0xf7, 0xd4, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x1f, 0xff, 0xb6,
	0x3c, 0x11, 0x0e, 0x00, 0x00,
}
