// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pay/pay.proto

/*
	Package pgPay is a generated protocol buffer package.

	It is generated from these files:
		pay/pay.proto

	It has these top-level messages:
		ConfigRequest
		ConfigResponse
		ConfigRespData
		TabRespData
		GoodsRespData
		PayRespData
		DescRespData
		GiftRespDetail
		OrderRequest
		OrderResponse
		OrderInfo
		ReportRequest
		ReportResponse
		SendMoneyRequest
		SendMoneyResponse
*/
package pgPay

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import bytes "bytes"

import strings "strings"
import reflect "reflect"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// ******************************* 商城配置start *************************************************//
type ConfigRequest struct {
	Mid              int64  `protobuf:"varint,1,req,name=mid" json:"mid"`
	TabId            int32  `protobuf:"varint,2,req,name=tabId" json:"tabId"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ConfigRequest) Reset()                    { *m = ConfigRequest{} }
func (*ConfigRequest) ProtoMessage()               {}
func (*ConfigRequest) Descriptor() ([]byte, []int) { return fileDescriptorPay, []int{0} }

func (m *ConfigRequest) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *ConfigRequest) GetTabId() int32 {
	if m != nil {
		return m.TabId
	}
	return 0
}

type ConfigResponse struct {
	Status           int32          `protobuf:"varint,1,req,name=status" json:"status"`
	Msg              string         `protobuf:"bytes,2,req,name=msg" json:"msg"`
	Data             ConfigRespData `protobuf:"bytes,3,opt,name=data" json:"data"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *ConfigResponse) Reset()                    { *m = ConfigResponse{} }
func (*ConfigResponse) ProtoMessage()               {}
func (*ConfigResponse) Descriptor() ([]byte, []int) { return fileDescriptorPay, []int{1} }

func (m *ConfigResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *ConfigResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ConfigResponse) GetData() ConfigRespData {
	if m != nil {
		return m.Data
	}
	return ConfigRespData{}
}

type ConfigRespData struct {
	TabConf          []TabRespData   `protobuf:"bytes,1,rep,name=tabConf" json:"tabConf"`
	Goods            []GoodsRespData `protobuf:"bytes,2,rep,name=goods" json:"goods"`
	TabId            int32           `protobuf:"varint,3,opt,name=tabId" json:"tabId"`
	XXX_unrecognized []byte          `json:"-"`
}

func (m *ConfigRespData) Reset()                    { *m = ConfigRespData{} }
func (*ConfigRespData) ProtoMessage()               {}
func (*ConfigRespData) Descriptor() ([]byte, []int) { return fileDescriptorPay, []int{2} }

func (m *ConfigRespData) GetTabConf() []TabRespData {
	if m != nil {
		return m.TabConf
	}
	return nil
}

func (m *ConfigRespData) GetGoods() []GoodsRespData {
	if m != nil {
		return m.Goods
	}
	return nil
}

func (m *ConfigRespData) GetTabId() int32 {
	if m != nil {
		return m.TabId
	}
	return 0
}

type TabRespData struct {
	Id               int32  `protobuf:"varint,1,opt,name=id" json:"id"`
	Name             string `protobuf:"bytes,2,opt,name=name" json:"name"`
	Order            int32  `protobuf:"varint,3,opt,name=order" json:"order"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TabRespData) Reset()                    { *m = TabRespData{} }
func (*TabRespData) ProtoMessage()               {}
func (*TabRespData) Descriptor() ([]byte, []int) { return fileDescriptorPay, []int{3} }

func (m *TabRespData) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TabRespData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TabRespData) GetOrder() int32 {
	if m != nil {
		return m.Order
	}
	return 0
}

type GoodsRespData struct {
	Gid              int32          `protobuf:"varint,1,opt,name=gid" json:"gid"`
	Name             string         `protobuf:"bytes,2,opt,name=name" json:"name"`
	Icon             string         `protobuf:"bytes,3,opt,name=icon" json:"icon"`
	Order            int32          `protobuf:"varint,4,opt,name=order" json:"order"`
	Desc             []DescRespData `protobuf:"bytes,5,rep,name=desc" json:"desc"`
	Pay              []PayRespData  `protobuf:"bytes,6,rep,name=pay" json:"pay"`
	LimitNum         int32          `protobuf:"varint,7,opt,name=limitNum" json:"limitNum"`
	LimitTotal       int32          `protobuf:"varint,8,opt,name=limitTotal" json:"limitTotal"`
	SellId           int32          `protobuf:"varint,9,opt,name=sellId" json:"sellId"`
	SellNum          int32          `protobuf:"varint,10,opt,name=sellNum" json:"sellNum"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *GoodsRespData) Reset()                    { *m = GoodsRespData{} }
func (*GoodsRespData) ProtoMessage()               {}
func (*GoodsRespData) Descriptor() ([]byte, []int) { return fileDescriptorPay, []int{4} }

func (m *GoodsRespData) GetGid() int32 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *GoodsRespData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GoodsRespData) GetIcon() string {
	if m != nil {
		return m.Icon
	}
	return ""
}

func (m *GoodsRespData) GetOrder() int32 {
	if m != nil {
		return m.Order
	}
	return 0
}

func (m *GoodsRespData) GetDesc() []DescRespData {
	if m != nil {
		return m.Desc
	}
	return nil
}

func (m *GoodsRespData) GetPay() []PayRespData {
	if m != nil {
		return m.Pay
	}
	return nil
}

func (m *GoodsRespData) GetLimitNum() int32 {
	if m != nil {
		return m.LimitNum
	}
	return 0
}

func (m *GoodsRespData) GetLimitTotal() int32 {
	if m != nil {
		return m.LimitTotal
	}
	return 0
}

func (m *GoodsRespData) GetSellId() int32 {
	if m != nil {
		return m.SellId
	}
	return 0
}

func (m *GoodsRespData) GetSellNum() int32 {
	if m != nil {
		return m.SellNum
	}
	return 0
}

// 购买（兑换）消耗的物品
type PayRespData struct {
	PayId            int32   `protobuf:"varint,1,opt,name=payId" json:"payId"`
	OldPayNum        float32 `protobuf:"fixed32,2,opt,name=oldPayNum" json:"oldPayNum"`
	PayNum           float32 `protobuf:"fixed32,3,opt,name=payNum" json:"payNum"`
	Pmode            string  `protobuf:"bytes,4,opt,name=pmode" json:"pmode"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PayRespData) Reset()                    { *m = PayRespData{} }
func (*PayRespData) ProtoMessage()               {}
func (*PayRespData) Descriptor() ([]byte, []int) { return fileDescriptorPay, []int{5} }

func (m *PayRespData) GetPayId() int32 {
	if m != nil {
		return m.PayId
	}
	return 0
}

func (m *PayRespData) GetOldPayNum() float32 {
	if m != nil {
		return m.OldPayNum
	}
	return 0
}

func (m *PayRespData) GetPayNum() float32 {
	if m != nil {
		return m.PayNum
	}
	return 0
}

func (m *PayRespData) GetPmode() string {
	if m != nil {
		return m.Pmode
	}
	return ""
}

// 获得的物品
type DescRespData struct {
	Type             int32            `protobuf:"varint,1,opt,name=type" json:"type"`
	FlagIcon         string           `protobuf:"bytes,2,opt,name=flagIcon" json:"flagIcon"`
	Desc             string           `protobuf:"bytes,3,opt,name=desc" json:"desc"`
	Detail           []GiftRespDetail `protobuf:"bytes,4,rep,name=detail" json:"detail"`
	Dorder           int32            `protobuf:"varint,5,opt,name=dorder" json:"dorder"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *DescRespData) Reset()                    { *m = DescRespData{} }
func (*DescRespData) ProtoMessage()               {}
func (*DescRespData) Descriptor() ([]byte, []int) { return fileDescriptorPay, []int{6} }

func (m *DescRespData) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *DescRespData) GetFlagIcon() string {
	if m != nil {
		return m.FlagIcon
	}
	return ""
}

func (m *DescRespData) GetDesc() string {
	if m != nil {
		return m.Desc
	}
	return ""
}

func (m *DescRespData) GetDetail() []GiftRespDetail {
	if m != nil {
		return m.Detail
	}
	return nil
}

func (m *DescRespData) GetDorder() int32 {
	if m != nil {
		return m.Dorder
	}
	return 0
}

type GiftRespDetail struct {
	GoodsId          int32  `protobuf:"varint,1,opt,name=goodsId" json:"goodsId"`
	GoodsNum         int32  `protobuf:"varint,2,opt,name=goodsNum" json:"goodsNum"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *GiftRespDetail) Reset()                    { *m = GiftRespDetail{} }
func (*GiftRespDetail) ProtoMessage()               {}
func (*GiftRespDetail) Descriptor() ([]byte, []int) { return fileDescriptorPay, []int{7} }

func (m *GiftRespDetail) GetGoodsId() int32 {
	if m != nil {
		return m.GoodsId
	}
	return 0
}

func (m *GiftRespDetail) GetGoodsNum() int32 {
	if m != nil {
		return m.GoodsNum
	}
	return 0
}

// ******************************* 商城配置end *************************************************//
// ******************************* 下单start *************************************************//
type OrderRequest struct {
	Mid              int64   `protobuf:"varint,1,opt,name=mid" json:"mid"`
	Pmode            int32   `protobuf:"varint,2,opt,name=pmode" json:"pmode"`
	Price            float32 `protobuf:"fixed32,3,opt,name=price" json:"price"`
	Number           int32   `protobuf:"varint,4,opt,name=number" json:"number"`
	Gid              int32   `protobuf:"varint,5,opt,name=gid" json:"gid"`
	TabId            int32   `protobuf:"varint,6,opt,name=tabId" json:"tabId"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *OrderRequest) Reset()                    { *m = OrderRequest{} }
func (*OrderRequest) ProtoMessage()               {}
func (*OrderRequest) Descriptor() ([]byte, []int) { return fileDescriptorPay, []int{8} }

func (m *OrderRequest) GetMid() int64 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *OrderRequest) GetPmode() int32 {
	if m != nil {
		return m.Pmode
	}
	return 0
}

func (m *OrderRequest) GetPrice() float32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *OrderRequest) GetNumber() int32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *OrderRequest) GetGid() int32 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *OrderRequest) GetTabId() int32 {
	if m != nil {
		return m.TabId
	}
	return 0
}

type OrderResponse struct {
	Status           int32     `protobuf:"varint,1,req,name=status" json:"status"`
	Msg              string    `protobuf:"bytes,2,req,name=msg" json:"msg"`
	Data             OrderInfo `protobuf:"bytes,3,opt,name=data" json:"data"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *OrderResponse) Reset()                    { *m = OrderResponse{} }
func (*OrderResponse) ProtoMessage()               {}
func (*OrderResponse) Descriptor() ([]byte, []int) { return fileDescriptorPay, []int{9} }

func (m *OrderResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *OrderResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *OrderResponse) GetData() OrderInfo {
	if m != nil {
		return m.Data
	}
	return OrderInfo{}
}

type OrderInfo struct {
	Order            string  `protobuf:"bytes,1,opt,name=order" json:"order"`
	Gid              int32   `protobuf:"varint,2,opt,name=gid" json:"gid"`
	Pamount          float32 `protobuf:"fixed32,3,opt,name=pamount" json:"pamount"`
	Pname            string  `protobuf:"bytes,4,opt,name=pname" json:"pname"`
	Mid              int32   `protobuf:"varint,5,opt,name=mid" json:"mid"`
	Ext              string  `protobuf:"bytes,6,opt,name=ext" json:"ext"`
	Pid              string  `protobuf:"bytes,7,opt,name=pid" json:"pid"`
	Pmode            int32   `protobuf:"varint,8,opt,name=pmode" json:"pmode"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *OrderInfo) Reset()                    { *m = OrderInfo{} }
func (*OrderInfo) ProtoMessage()               {}
func (*OrderInfo) Descriptor() ([]byte, []int) { return fileDescriptorPay, []int{10} }

func (m *OrderInfo) GetOrder() string {
	if m != nil {
		return m.Order
	}
	return ""
}

func (m *OrderInfo) GetGid() int32 {
	if m != nil {
		return m.Gid
	}
	return 0
}

func (m *OrderInfo) GetPamount() float32 {
	if m != nil {
		return m.Pamount
	}
	return 0
}

func (m *OrderInfo) GetPname() string {
	if m != nil {
		return m.Pname
	}
	return ""
}

func (m *OrderInfo) GetMid() int32 {
	if m != nil {
		return m.Mid
	}
	return 0
}

func (m *OrderInfo) GetExt() string {
	if m != nil {
		return m.Ext
	}
	return ""
}

func (m *OrderInfo) GetPid() string {
	if m != nil {
		return m.Pid
	}
	return ""
}

func (m *OrderInfo) GetPmode() int32 {
	if m != nil {
		return m.Pmode
	}
	return 0
}

// ******************************* 下单end *************************************************//
// ******************************* 通知发货start *******************************************//
type ReportRequest struct {
	Pid              string `protobuf:"bytes,1,req,name=pid" json:"pid"`
	Content          string `protobuf:"bytes,2,req,name=content" json:"content"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ReportRequest) Reset()                    { *m = ReportRequest{} }
func (*ReportRequest) ProtoMessage()               {}
func (*ReportRequest) Descriptor() ([]byte, []int) { return fileDescriptorPay, []int{11} }

func (m *ReportRequest) GetPid() string {
	if m != nil {
		return m.Pid
	}
	return ""
}

func (m *ReportRequest) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

type ReportResponse struct {
	Status           int32  `protobuf:"varint,1,req,name=status" json:"status"`
	Msg              string `protobuf:"bytes,2,req,name=msg" json:"msg"`
	Data             string `protobuf:"bytes,3,req,name=data" json:"data"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ReportResponse) Reset()                    { *m = ReportResponse{} }
func (*ReportResponse) ProtoMessage()               {}
func (*ReportResponse) Descriptor() ([]byte, []int) { return fileDescriptorPay, []int{12} }

func (m *ReportResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *ReportResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ReportResponse) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

// ******************************* 通知发货end *******************************************//
// ******************************* 通知发货start *******************************************//
type SendMoneyRequest struct {
	Content          string `protobuf:"bytes,1,req,name=content" json:"content"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SendMoneyRequest) Reset()                    { *m = SendMoneyRequest{} }
func (*SendMoneyRequest) ProtoMessage()               {}
func (*SendMoneyRequest) Descriptor() ([]byte, []int) { return fileDescriptorPay, []int{13} }

func (m *SendMoneyRequest) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

type SendMoneyResponse struct {
	Status           int32  `protobuf:"varint,1,req,name=status" json:"status"`
	Msg              string `protobuf:"bytes,2,req,name=msg" json:"msg"`
	Data             string `protobuf:"bytes,3,req,name=data" json:"data"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *SendMoneyResponse) Reset()                    { *m = SendMoneyResponse{} }
func (*SendMoneyResponse) ProtoMessage()               {}
func (*SendMoneyResponse) Descriptor() ([]byte, []int) { return fileDescriptorPay, []int{14} }

func (m *SendMoneyResponse) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *SendMoneyResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *SendMoneyResponse) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func init() {
	proto.RegisterType((*ConfigRequest)(nil), "pgPay.ConfigRequest")
	proto.RegisterType((*ConfigResponse)(nil), "pgPay.ConfigResponse")
	proto.RegisterType((*ConfigRespData)(nil), "pgPay.ConfigRespData")
	proto.RegisterType((*TabRespData)(nil), "pgPay.TabRespData")
	proto.RegisterType((*GoodsRespData)(nil), "pgPay.GoodsRespData")
	proto.RegisterType((*PayRespData)(nil), "pgPay.PayRespData")
	proto.RegisterType((*DescRespData)(nil), "pgPay.DescRespData")
	proto.RegisterType((*GiftRespDetail)(nil), "pgPay.GiftRespDetail")
	proto.RegisterType((*OrderRequest)(nil), "pgPay.OrderRequest")
	proto.RegisterType((*OrderResponse)(nil), "pgPay.OrderResponse")
	proto.RegisterType((*OrderInfo)(nil), "pgPay.OrderInfo")
	proto.RegisterType((*ReportRequest)(nil), "pgPay.ReportRequest")
	proto.RegisterType((*ReportResponse)(nil), "pgPay.ReportResponse")
	proto.RegisterType((*SendMoneyRequest)(nil), "pgPay.SendMoneyRequest")
	proto.RegisterType((*SendMoneyResponse)(nil), "pgPay.SendMoneyResponse")
}
func (this *ConfigRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ConfigRequest)
	if !ok {
		that2, ok := that.(ConfigRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ConfigRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ConfigRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ConfigRequest but is not nil && this == nil")
	}
	if this.Mid != that1.Mid {
		return fmt.Errorf("Mid this(%v) Not Equal that(%v)", this.Mid, that1.Mid)
	}
	if this.TabId != that1.TabId {
		return fmt.Errorf("TabId this(%v) Not Equal that(%v)", this.TabId, that1.TabId)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ConfigRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConfigRequest)
	if !ok {
		that2, ok := that.(ConfigRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mid != that1.Mid {
		return false
	}
	if this.TabId != that1.TabId {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ConfigResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ConfigResponse)
	if !ok {
		that2, ok := that.(ConfigResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ConfigResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ConfigResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ConfigResponse but is not nil && this == nil")
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if this.Msg != that1.Msg {
		return fmt.Errorf("Msg this(%v) Not Equal that(%v)", this.Msg, that1.Msg)
	}
	if !this.Data.Equal(&that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ConfigResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConfigResponse)
	if !ok {
		that2, ok := that.(ConfigResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Msg != that1.Msg {
		return false
	}
	if !this.Data.Equal(&that1.Data) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ConfigRespData) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ConfigRespData)
	if !ok {
		that2, ok := that.(ConfigRespData)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ConfigRespData")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ConfigRespData but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ConfigRespData but is not nil && this == nil")
	}
	if len(this.TabConf) != len(that1.TabConf) {
		return fmt.Errorf("TabConf this(%v) Not Equal that(%v)", len(this.TabConf), len(that1.TabConf))
	}
	for i := range this.TabConf {
		if !this.TabConf[i].Equal(&that1.TabConf[i]) {
			return fmt.Errorf("TabConf this[%v](%v) Not Equal that[%v](%v)", i, this.TabConf[i], i, that1.TabConf[i])
		}
	}
	if len(this.Goods) != len(that1.Goods) {
		return fmt.Errorf("Goods this(%v) Not Equal that(%v)", len(this.Goods), len(that1.Goods))
	}
	for i := range this.Goods {
		if !this.Goods[i].Equal(&that1.Goods[i]) {
			return fmt.Errorf("Goods this[%v](%v) Not Equal that[%v](%v)", i, this.Goods[i], i, that1.Goods[i])
		}
	}
	if this.TabId != that1.TabId {
		return fmt.Errorf("TabId this(%v) Not Equal that(%v)", this.TabId, that1.TabId)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ConfigRespData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConfigRespData)
	if !ok {
		that2, ok := that.(ConfigRespData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.TabConf) != len(that1.TabConf) {
		return false
	}
	for i := range this.TabConf {
		if !this.TabConf[i].Equal(&that1.TabConf[i]) {
			return false
		}
	}
	if len(this.Goods) != len(that1.Goods) {
		return false
	}
	for i := range this.Goods {
		if !this.Goods[i].Equal(&that1.Goods[i]) {
			return false
		}
	}
	if this.TabId != that1.TabId {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *TabRespData) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TabRespData)
	if !ok {
		that2, ok := that.(TabRespData)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TabRespData")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TabRespData but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TabRespData but is not nil && this == nil")
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Order != that1.Order {
		return fmt.Errorf("Order this(%v) Not Equal that(%v)", this.Order, that1.Order)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *TabRespData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TabRespData)
	if !ok {
		that2, ok := that.(TabRespData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Order != that1.Order {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GoodsRespData) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GoodsRespData)
	if !ok {
		that2, ok := that.(GoodsRespData)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GoodsRespData")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GoodsRespData but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GoodsRespData but is not nil && this == nil")
	}
	if this.Gid != that1.Gid {
		return fmt.Errorf("Gid this(%v) Not Equal that(%v)", this.Gid, that1.Gid)
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Icon != that1.Icon {
		return fmt.Errorf("Icon this(%v) Not Equal that(%v)", this.Icon, that1.Icon)
	}
	if this.Order != that1.Order {
		return fmt.Errorf("Order this(%v) Not Equal that(%v)", this.Order, that1.Order)
	}
	if len(this.Desc) != len(that1.Desc) {
		return fmt.Errorf("Desc this(%v) Not Equal that(%v)", len(this.Desc), len(that1.Desc))
	}
	for i := range this.Desc {
		if !this.Desc[i].Equal(&that1.Desc[i]) {
			return fmt.Errorf("Desc this[%v](%v) Not Equal that[%v](%v)", i, this.Desc[i], i, that1.Desc[i])
		}
	}
	if len(this.Pay) != len(that1.Pay) {
		return fmt.Errorf("Pay this(%v) Not Equal that(%v)", len(this.Pay), len(that1.Pay))
	}
	for i := range this.Pay {
		if !this.Pay[i].Equal(&that1.Pay[i]) {
			return fmt.Errorf("Pay this[%v](%v) Not Equal that[%v](%v)", i, this.Pay[i], i, that1.Pay[i])
		}
	}
	if this.LimitNum != that1.LimitNum {
		return fmt.Errorf("LimitNum this(%v) Not Equal that(%v)", this.LimitNum, that1.LimitNum)
	}
	if this.LimitTotal != that1.LimitTotal {
		return fmt.Errorf("LimitTotal this(%v) Not Equal that(%v)", this.LimitTotal, that1.LimitTotal)
	}
	if this.SellId != that1.SellId {
		return fmt.Errorf("SellId this(%v) Not Equal that(%v)", this.SellId, that1.SellId)
	}
	if this.SellNum != that1.SellNum {
		return fmt.Errorf("SellNum this(%v) Not Equal that(%v)", this.SellNum, that1.SellNum)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *GoodsRespData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GoodsRespData)
	if !ok {
		that2, ok := that.(GoodsRespData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Gid != that1.Gid {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Icon != that1.Icon {
		return false
	}
	if this.Order != that1.Order {
		return false
	}
	if len(this.Desc) != len(that1.Desc) {
		return false
	}
	for i := range this.Desc {
		if !this.Desc[i].Equal(&that1.Desc[i]) {
			return false
		}
	}
	if len(this.Pay) != len(that1.Pay) {
		return false
	}
	for i := range this.Pay {
		if !this.Pay[i].Equal(&that1.Pay[i]) {
			return false
		}
	}
	if this.LimitNum != that1.LimitNum {
		return false
	}
	if this.LimitTotal != that1.LimitTotal {
		return false
	}
	if this.SellId != that1.SellId {
		return false
	}
	if this.SellNum != that1.SellNum {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *PayRespData) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PayRespData)
	if !ok {
		that2, ok := that.(PayRespData)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PayRespData")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PayRespData but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PayRespData but is not nil && this == nil")
	}
	if this.PayId != that1.PayId {
		return fmt.Errorf("PayId this(%v) Not Equal that(%v)", this.PayId, that1.PayId)
	}
	if this.OldPayNum != that1.OldPayNum {
		return fmt.Errorf("OldPayNum this(%v) Not Equal that(%v)", this.OldPayNum, that1.OldPayNum)
	}
	if this.PayNum != that1.PayNum {
		return fmt.Errorf("PayNum this(%v) Not Equal that(%v)", this.PayNum, that1.PayNum)
	}
	if this.Pmode != that1.Pmode {
		return fmt.Errorf("Pmode this(%v) Not Equal that(%v)", this.Pmode, that1.Pmode)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *PayRespData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PayRespData)
	if !ok {
		that2, ok := that.(PayRespData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PayId != that1.PayId {
		return false
	}
	if this.OldPayNum != that1.OldPayNum {
		return false
	}
	if this.PayNum != that1.PayNum {
		return false
	}
	if this.Pmode != that1.Pmode {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DescRespData) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DescRespData)
	if !ok {
		that2, ok := that.(DescRespData)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DescRespData")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DescRespData but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DescRespData but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.FlagIcon != that1.FlagIcon {
		return fmt.Errorf("FlagIcon this(%v) Not Equal that(%v)", this.FlagIcon, that1.FlagIcon)
	}
	if this.Desc != that1.Desc {
		return fmt.Errorf("Desc this(%v) Not Equal that(%v)", this.Desc, that1.Desc)
	}
	if len(this.Detail) != len(that1.Detail) {
		return fmt.Errorf("Detail this(%v) Not Equal that(%v)", len(this.Detail), len(that1.Detail))
	}
	for i := range this.Detail {
		if !this.Detail[i].Equal(&that1.Detail[i]) {
			return fmt.Errorf("Detail this[%v](%v) Not Equal that[%v](%v)", i, this.Detail[i], i, that1.Detail[i])
		}
	}
	if this.Dorder != that1.Dorder {
		return fmt.Errorf("Dorder this(%v) Not Equal that(%v)", this.Dorder, that1.Dorder)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *DescRespData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DescRespData)
	if !ok {
		that2, ok := that.(DescRespData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.FlagIcon != that1.FlagIcon {
		return false
	}
	if this.Desc != that1.Desc {
		return false
	}
	if len(this.Detail) != len(that1.Detail) {
		return false
	}
	for i := range this.Detail {
		if !this.Detail[i].Equal(&that1.Detail[i]) {
			return false
		}
	}
	if this.Dorder != that1.Dorder {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *GiftRespDetail) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*GiftRespDetail)
	if !ok {
		that2, ok := that.(GiftRespDetail)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *GiftRespDetail")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *GiftRespDetail but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *GiftRespDetail but is not nil && this == nil")
	}
	if this.GoodsId != that1.GoodsId {
		return fmt.Errorf("GoodsId this(%v) Not Equal that(%v)", this.GoodsId, that1.GoodsId)
	}
	if this.GoodsNum != that1.GoodsNum {
		return fmt.Errorf("GoodsNum this(%v) Not Equal that(%v)", this.GoodsNum, that1.GoodsNum)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *GiftRespDetail) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GiftRespDetail)
	if !ok {
		that2, ok := that.(GiftRespDetail)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GoodsId != that1.GoodsId {
		return false
	}
	if this.GoodsNum != that1.GoodsNum {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *OrderRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OrderRequest)
	if !ok {
		that2, ok := that.(OrderRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OrderRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OrderRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OrderRequest but is not nil && this == nil")
	}
	if this.Mid != that1.Mid {
		return fmt.Errorf("Mid this(%v) Not Equal that(%v)", this.Mid, that1.Mid)
	}
	if this.Pmode != that1.Pmode {
		return fmt.Errorf("Pmode this(%v) Not Equal that(%v)", this.Pmode, that1.Pmode)
	}
	if this.Price != that1.Price {
		return fmt.Errorf("Price this(%v) Not Equal that(%v)", this.Price, that1.Price)
	}
	if this.Number != that1.Number {
		return fmt.Errorf("Number this(%v) Not Equal that(%v)", this.Number, that1.Number)
	}
	if this.Gid != that1.Gid {
		return fmt.Errorf("Gid this(%v) Not Equal that(%v)", this.Gid, that1.Gid)
	}
	if this.TabId != that1.TabId {
		return fmt.Errorf("TabId this(%v) Not Equal that(%v)", this.TabId, that1.TabId)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *OrderRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderRequest)
	if !ok {
		that2, ok := that.(OrderRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Mid != that1.Mid {
		return false
	}
	if this.Pmode != that1.Pmode {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	if this.Number != that1.Number {
		return false
	}
	if this.Gid != that1.Gid {
		return false
	}
	if this.TabId != that1.TabId {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *OrderResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OrderResponse)
	if !ok {
		that2, ok := that.(OrderResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OrderResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OrderResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OrderResponse but is not nil && this == nil")
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if this.Msg != that1.Msg {
		return fmt.Errorf("Msg this(%v) Not Equal that(%v)", this.Msg, that1.Msg)
	}
	if !this.Data.Equal(&that1.Data) {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *OrderResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderResponse)
	if !ok {
		that2, ok := that.(OrderResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Msg != that1.Msg {
		return false
	}
	if !this.Data.Equal(&that1.Data) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *OrderInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*OrderInfo)
	if !ok {
		that2, ok := that.(OrderInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *OrderInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *OrderInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *OrderInfo but is not nil && this == nil")
	}
	if this.Order != that1.Order {
		return fmt.Errorf("Order this(%v) Not Equal that(%v)", this.Order, that1.Order)
	}
	if this.Gid != that1.Gid {
		return fmt.Errorf("Gid this(%v) Not Equal that(%v)", this.Gid, that1.Gid)
	}
	if this.Pamount != that1.Pamount {
		return fmt.Errorf("Pamount this(%v) Not Equal that(%v)", this.Pamount, that1.Pamount)
	}
	if this.Pname != that1.Pname {
		return fmt.Errorf("Pname this(%v) Not Equal that(%v)", this.Pname, that1.Pname)
	}
	if this.Mid != that1.Mid {
		return fmt.Errorf("Mid this(%v) Not Equal that(%v)", this.Mid, that1.Mid)
	}
	if this.Ext != that1.Ext {
		return fmt.Errorf("Ext this(%v) Not Equal that(%v)", this.Ext, that1.Ext)
	}
	if this.Pid != that1.Pid {
		return fmt.Errorf("Pid this(%v) Not Equal that(%v)", this.Pid, that1.Pid)
	}
	if this.Pmode != that1.Pmode {
		return fmt.Errorf("Pmode this(%v) Not Equal that(%v)", this.Pmode, that1.Pmode)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *OrderInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderInfo)
	if !ok {
		that2, ok := that.(OrderInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Order != that1.Order {
		return false
	}
	if this.Gid != that1.Gid {
		return false
	}
	if this.Pamount != that1.Pamount {
		return false
	}
	if this.Pname != that1.Pname {
		return false
	}
	if this.Mid != that1.Mid {
		return false
	}
	if this.Ext != that1.Ext {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	if this.Pmode != that1.Pmode {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ReportRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ReportRequest)
	if !ok {
		that2, ok := that.(ReportRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ReportRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ReportRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ReportRequest but is not nil && this == nil")
	}
	if this.Pid != that1.Pid {
		return fmt.Errorf("Pid this(%v) Not Equal that(%v)", this.Pid, that1.Pid)
	}
	if this.Content != that1.Content {
		return fmt.Errorf("Content this(%v) Not Equal that(%v)", this.Content, that1.Content)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ReportRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReportRequest)
	if !ok {
		that2, ok := that.(ReportRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Pid != that1.Pid {
		return false
	}
	if this.Content != that1.Content {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ReportResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ReportResponse)
	if !ok {
		that2, ok := that.(ReportResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ReportResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ReportResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ReportResponse but is not nil && this == nil")
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if this.Msg != that1.Msg {
		return fmt.Errorf("Msg this(%v) Not Equal that(%v)", this.Msg, that1.Msg)
	}
	if this.Data != that1.Data {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ReportResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReportResponse)
	if !ok {
		that2, ok := that.(ReportResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Msg != that1.Msg {
		return false
	}
	if this.Data != that1.Data {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *SendMoneyRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SendMoneyRequest)
	if !ok {
		that2, ok := that.(SendMoneyRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SendMoneyRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SendMoneyRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SendMoneyRequest but is not nil && this == nil")
	}
	if this.Content != that1.Content {
		return fmt.Errorf("Content this(%v) Not Equal that(%v)", this.Content, that1.Content)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *SendMoneyRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendMoneyRequest)
	if !ok {
		that2, ok := that.(SendMoneyRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Content != that1.Content {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *SendMoneyResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SendMoneyResponse)
	if !ok {
		that2, ok := that.(SendMoneyResponse)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SendMoneyResponse")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SendMoneyResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SendMoneyResponse but is not nil && this == nil")
	}
	if this.Status != that1.Status {
		return fmt.Errorf("Status this(%v) Not Equal that(%v)", this.Status, that1.Status)
	}
	if this.Msg != that1.Msg {
		return fmt.Errorf("Msg this(%v) Not Equal that(%v)", this.Msg, that1.Msg)
	}
	if this.Data != that1.Data {
		return fmt.Errorf("Data this(%v) Not Equal that(%v)", this.Data, that1.Data)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *SendMoneyResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SendMoneyResponse)
	if !ok {
		that2, ok := that.(SendMoneyResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Msg != that1.Msg {
		return false
	}
	if this.Data != that1.Data {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ConfigRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pgPay.ConfigRequest{")
	s = append(s, "Mid: "+fmt.Sprintf("%#v", this.Mid)+",\n")
	s = append(s, "TabId: "+fmt.Sprintf("%#v", this.TabId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConfigResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pgPay.ConfigResponse{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	s = append(s, "Data: "+strings.Replace(this.Data.GoString(), `&`, ``, 1)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ConfigRespData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pgPay.ConfigRespData{")
	if this.TabConf != nil {
		vs := make([]*TabRespData, len(this.TabConf))
		for i := range vs {
			vs[i] = &this.TabConf[i]
		}
		s = append(s, "TabConf: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Goods != nil {
		vs := make([]*GoodsRespData, len(this.Goods))
		for i := range vs {
			vs[i] = &this.Goods[i]
		}
		s = append(s, "Goods: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "TabId: "+fmt.Sprintf("%#v", this.TabId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TabRespData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pgPay.TabRespData{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Order: "+fmt.Sprintf("%#v", this.Order)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GoodsRespData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&pgPay.GoodsRespData{")
	s = append(s, "Gid: "+fmt.Sprintf("%#v", this.Gid)+",\n")
	s = append(s, "Name: "+fmt.Sprintf("%#v", this.Name)+",\n")
	s = append(s, "Icon: "+fmt.Sprintf("%#v", this.Icon)+",\n")
	s = append(s, "Order: "+fmt.Sprintf("%#v", this.Order)+",\n")
	if this.Desc != nil {
		vs := make([]*DescRespData, len(this.Desc))
		for i := range vs {
			vs[i] = &this.Desc[i]
		}
		s = append(s, "Desc: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	if this.Pay != nil {
		vs := make([]*PayRespData, len(this.Pay))
		for i := range vs {
			vs[i] = &this.Pay[i]
		}
		s = append(s, "Pay: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "LimitNum: "+fmt.Sprintf("%#v", this.LimitNum)+",\n")
	s = append(s, "LimitTotal: "+fmt.Sprintf("%#v", this.LimitTotal)+",\n")
	s = append(s, "SellId: "+fmt.Sprintf("%#v", this.SellId)+",\n")
	s = append(s, "SellNum: "+fmt.Sprintf("%#v", this.SellNum)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PayRespData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&pgPay.PayRespData{")
	s = append(s, "PayId: "+fmt.Sprintf("%#v", this.PayId)+",\n")
	s = append(s, "OldPayNum: "+fmt.Sprintf("%#v", this.OldPayNum)+",\n")
	s = append(s, "PayNum: "+fmt.Sprintf("%#v", this.PayNum)+",\n")
	s = append(s, "Pmode: "+fmt.Sprintf("%#v", this.Pmode)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DescRespData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&pgPay.DescRespData{")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "FlagIcon: "+fmt.Sprintf("%#v", this.FlagIcon)+",\n")
	s = append(s, "Desc: "+fmt.Sprintf("%#v", this.Desc)+",\n")
	if this.Detail != nil {
		vs := make([]*GiftRespDetail, len(this.Detail))
		for i := range vs {
			vs[i] = &this.Detail[i]
		}
		s = append(s, "Detail: "+fmt.Sprintf("%#v", vs)+",\n")
	}
	s = append(s, "Dorder: "+fmt.Sprintf("%#v", this.Dorder)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GiftRespDetail) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pgPay.GiftRespDetail{")
	s = append(s, "GoodsId: "+fmt.Sprintf("%#v", this.GoodsId)+",\n")
	s = append(s, "GoodsNum: "+fmt.Sprintf("%#v", this.GoodsNum)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&pgPay.OrderRequest{")
	s = append(s, "Mid: "+fmt.Sprintf("%#v", this.Mid)+",\n")
	s = append(s, "Pmode: "+fmt.Sprintf("%#v", this.Pmode)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	s = append(s, "Number: "+fmt.Sprintf("%#v", this.Number)+",\n")
	s = append(s, "Gid: "+fmt.Sprintf("%#v", this.Gid)+",\n")
	s = append(s, "TabId: "+fmt.Sprintf("%#v", this.TabId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pgPay.OrderResponse{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	s = append(s, "Data: "+strings.Replace(this.Data.GoString(), `&`, ``, 1)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&pgPay.OrderInfo{")
	s = append(s, "Order: "+fmt.Sprintf("%#v", this.Order)+",\n")
	s = append(s, "Gid: "+fmt.Sprintf("%#v", this.Gid)+",\n")
	s = append(s, "Pamount: "+fmt.Sprintf("%#v", this.Pamount)+",\n")
	s = append(s, "Pname: "+fmt.Sprintf("%#v", this.Pname)+",\n")
	s = append(s, "Mid: "+fmt.Sprintf("%#v", this.Mid)+",\n")
	s = append(s, "Ext: "+fmt.Sprintf("%#v", this.Ext)+",\n")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	s = append(s, "Pmode: "+fmt.Sprintf("%#v", this.Pmode)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReportRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&pgPay.ReportRequest{")
	s = append(s, "Pid: "+fmt.Sprintf("%#v", this.Pid)+",\n")
	s = append(s, "Content: "+fmt.Sprintf("%#v", this.Content)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ReportResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pgPay.ReportResponse{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendMoneyRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&pgPay.SendMoneyRequest{")
	s = append(s, "Content: "+fmt.Sprintf("%#v", this.Content)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SendMoneyResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&pgPay.SendMoneyResponse{")
	s = append(s, "Status: "+fmt.Sprintf("%#v", this.Status)+",\n")
	s = append(s, "Msg: "+fmt.Sprintf("%#v", this.Msg)+",\n")
	s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringPay(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Mid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.TabId))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Status))
	dAtA[i] = 0x12
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Msg)))
	i += copy(dAtA[i:], m.Msg)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Data.Size()))
	n1, err := m.Data.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigRespData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigRespData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TabConf) > 0 {
		for _, msg := range m.TabConf {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPay(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Goods) > 0 {
		for _, msg := range m.Goods {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPay(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x18
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.TabId))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TabRespData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TabRespData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Id))
	dAtA[i] = 0x12
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x18
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Order))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GoodsRespData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoodsRespData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Gid))
	dAtA[i] = 0x12
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Icon)))
	i += copy(dAtA[i:], m.Icon)
	dAtA[i] = 0x20
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Order))
	if len(m.Desc) > 0 {
		for _, msg := range m.Desc {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintPay(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Pay) > 0 {
		for _, msg := range m.Pay {
			dAtA[i] = 0x32
			i++
			i = encodeVarintPay(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x38
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.LimitNum))
	dAtA[i] = 0x40
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.LimitTotal))
	dAtA[i] = 0x48
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.SellId))
	dAtA[i] = 0x50
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.SellNum))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PayRespData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayRespData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.PayId))
	dAtA[i] = 0x15
	i++
	binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.OldPayNum))))
	i += 4
	dAtA[i] = 0x1d
	i++
	binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PayNum))))
	i += 4
	dAtA[i] = 0x22
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Pmode)))
	i += copy(dAtA[i:], m.Pmode)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DescRespData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescRespData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x12
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.FlagIcon)))
	i += copy(dAtA[i:], m.FlagIcon)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Desc)))
	i += copy(dAtA[i:], m.Desc)
	if len(m.Detail) > 0 {
		for _, msg := range m.Detail {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPay(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x28
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Dorder))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GiftRespDetail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GiftRespDetail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.GoodsId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.GoodsNum))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Mid))
	dAtA[i] = 0x10
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Pmode))
	dAtA[i] = 0x1d
	i++
	binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Price))))
	i += 4
	dAtA[i] = 0x20
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Number))
	dAtA[i] = 0x28
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Gid))
	dAtA[i] = 0x30
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.TabId))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Status))
	dAtA[i] = 0x12
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Msg)))
	i += copy(dAtA[i:], m.Msg)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Data.Size()))
	n2, err := m.Data.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OrderInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Order)))
	i += copy(dAtA[i:], m.Order)
	dAtA[i] = 0x10
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Gid))
	dAtA[i] = 0x1d
	i++
	binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Pamount))))
	i += 4
	dAtA[i] = 0x22
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Pname)))
	i += copy(dAtA[i:], m.Pname)
	dAtA[i] = 0x28
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Mid))
	dAtA[i] = 0x32
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Ext)))
	i += copy(dAtA[i:], m.Ext)
	dAtA[i] = 0x3a
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Pid)))
	i += copy(dAtA[i:], m.Pid)
	dAtA[i] = 0x40
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Pmode))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReportRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Pid)))
	i += copy(dAtA[i:], m.Pid)
	dAtA[i] = 0x12
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Content)))
	i += copy(dAtA[i:], m.Content)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReportResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Status))
	dAtA[i] = 0x12
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Msg)))
	i += copy(dAtA[i:], m.Msg)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Data)))
	i += copy(dAtA[i:], m.Data)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SendMoneyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMoneyRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Content)))
	i += copy(dAtA[i:], m.Content)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SendMoneyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendMoneyResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPay(dAtA, i, uint64(m.Status))
	dAtA[i] = 0x12
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Msg)))
	i += copy(dAtA[i:], m.Msg)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintPay(dAtA, i, uint64(len(m.Data)))
	i += copy(dAtA[i:], m.Data)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintPay(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedConfigRequest(r randyPay, easy bool) *ConfigRequest {
	this := &ConfigRequest{}
	this.Mid = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Mid *= -1
	}
	this.TabId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.TabId *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPay(r, 3)
	}
	return this
}

func NewPopulatedConfigResponse(r randyPay, easy bool) *ConfigResponse {
	this := &ConfigResponse{}
	this.Status = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Status *= -1
	}
	this.Msg = string(randStringPay(r))
	v1 := NewPopulatedConfigRespData(r, easy)
	this.Data = *v1
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPay(r, 4)
	}
	return this
}

func NewPopulatedConfigRespData(r randyPay, easy bool) *ConfigRespData {
	this := &ConfigRespData{}
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.TabConf = make([]TabRespData, v2)
		for i := 0; i < v2; i++ {
			v3 := NewPopulatedTabRespData(r, easy)
			this.TabConf[i] = *v3
		}
	}
	if r.Intn(10) != 0 {
		v4 := r.Intn(5)
		this.Goods = make([]GoodsRespData, v4)
		for i := 0; i < v4; i++ {
			v5 := NewPopulatedGoodsRespData(r, easy)
			this.Goods[i] = *v5
		}
	}
	this.TabId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.TabId *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPay(r, 4)
	}
	return this
}

func NewPopulatedTabRespData(r randyPay, easy bool) *TabRespData {
	this := &TabRespData{}
	this.Id = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Id *= -1
	}
	this.Name = string(randStringPay(r))
	this.Order = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Order *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPay(r, 4)
	}
	return this
}

func NewPopulatedGoodsRespData(r randyPay, easy bool) *GoodsRespData {
	this := &GoodsRespData{}
	this.Gid = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Gid *= -1
	}
	this.Name = string(randStringPay(r))
	this.Icon = string(randStringPay(r))
	this.Order = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Order *= -1
	}
	if r.Intn(10) != 0 {
		v6 := r.Intn(5)
		this.Desc = make([]DescRespData, v6)
		for i := 0; i < v6; i++ {
			v7 := NewPopulatedDescRespData(r, easy)
			this.Desc[i] = *v7
		}
	}
	if r.Intn(10) != 0 {
		v8 := r.Intn(5)
		this.Pay = make([]PayRespData, v8)
		for i := 0; i < v8; i++ {
			v9 := NewPopulatedPayRespData(r, easy)
			this.Pay[i] = *v9
		}
	}
	this.LimitNum = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.LimitNum *= -1
	}
	this.LimitTotal = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.LimitTotal *= -1
	}
	this.SellId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.SellId *= -1
	}
	this.SellNum = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.SellNum *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPay(r, 11)
	}
	return this
}

func NewPopulatedPayRespData(r randyPay, easy bool) *PayRespData {
	this := &PayRespData{}
	this.PayId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.PayId *= -1
	}
	this.OldPayNum = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.OldPayNum *= -1
	}
	this.PayNum = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.PayNum *= -1
	}
	this.Pmode = string(randStringPay(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPay(r, 5)
	}
	return this
}

func NewPopulatedDescRespData(r randyPay, easy bool) *DescRespData {
	this := &DescRespData{}
	this.Type = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Type *= -1
	}
	this.FlagIcon = string(randStringPay(r))
	this.Desc = string(randStringPay(r))
	if r.Intn(10) != 0 {
		v10 := r.Intn(5)
		this.Detail = make([]GiftRespDetail, v10)
		for i := 0; i < v10; i++ {
			v11 := NewPopulatedGiftRespDetail(r, easy)
			this.Detail[i] = *v11
		}
	}
	this.Dorder = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Dorder *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPay(r, 6)
	}
	return this
}

func NewPopulatedGiftRespDetail(r randyPay, easy bool) *GiftRespDetail {
	this := &GiftRespDetail{}
	this.GoodsId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.GoodsId *= -1
	}
	this.GoodsNum = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.GoodsNum *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPay(r, 3)
	}
	return this
}

func NewPopulatedOrderRequest(r randyPay, easy bool) *OrderRequest {
	this := &OrderRequest{}
	this.Mid = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.Mid *= -1
	}
	this.Pmode = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Pmode *= -1
	}
	this.Price = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.Price *= -1
	}
	this.Number = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Number *= -1
	}
	this.Gid = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Gid *= -1
	}
	this.TabId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.TabId *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPay(r, 7)
	}
	return this
}

func NewPopulatedOrderResponse(r randyPay, easy bool) *OrderResponse {
	this := &OrderResponse{}
	this.Status = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Status *= -1
	}
	this.Msg = string(randStringPay(r))
	v12 := NewPopulatedOrderInfo(r, easy)
	this.Data = *v12
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPay(r, 4)
	}
	return this
}

func NewPopulatedOrderInfo(r randyPay, easy bool) *OrderInfo {
	this := &OrderInfo{}
	this.Order = string(randStringPay(r))
	this.Gid = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Gid *= -1
	}
	this.Pamount = float32(r.Float32())
	if r.Intn(2) == 0 {
		this.Pamount *= -1
	}
	this.Pname = string(randStringPay(r))
	this.Mid = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Mid *= -1
	}
	this.Ext = string(randStringPay(r))
	this.Pid = string(randStringPay(r))
	this.Pmode = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Pmode *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPay(r, 9)
	}
	return this
}

func NewPopulatedReportRequest(r randyPay, easy bool) *ReportRequest {
	this := &ReportRequest{}
	this.Pid = string(randStringPay(r))
	this.Content = string(randStringPay(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPay(r, 3)
	}
	return this
}

func NewPopulatedReportResponse(r randyPay, easy bool) *ReportResponse {
	this := &ReportResponse{}
	this.Status = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Status *= -1
	}
	this.Msg = string(randStringPay(r))
	this.Data = string(randStringPay(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPay(r, 4)
	}
	return this
}

func NewPopulatedSendMoneyRequest(r randyPay, easy bool) *SendMoneyRequest {
	this := &SendMoneyRequest{}
	this.Content = string(randStringPay(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPay(r, 2)
	}
	return this
}

func NewPopulatedSendMoneyResponse(r randyPay, easy bool) *SendMoneyResponse {
	this := &SendMoneyResponse{}
	this.Status = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Status *= -1
	}
	this.Msg = string(randStringPay(r))
	this.Data = string(randStringPay(r))
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedPay(r, 4)
	}
	return this
}

type randyPay interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RunePay(r randyPay) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringPay(r randyPay) string {
	v13 := r.Intn(100)
	tmps := make([]rune, v13)
	for i := 0; i < v13; i++ {
		tmps[i] = randUTF8RunePay(r)
	}
	return string(tmps)
}
func randUnrecognizedPay(r randyPay, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldPay(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldPay(dAtA []byte, r randyPay, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulatePay(dAtA, uint64(key))
		v14 := r.Int63()
		if r.Intn(2) == 0 {
			v14 *= -1
		}
		dAtA = encodeVarintPopulatePay(dAtA, uint64(v14))
	case 1:
		dAtA = encodeVarintPopulatePay(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulatePay(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulatePay(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulatePay(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulatePay(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *ConfigRequest) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPay(uint64(m.Mid))
	n += 1 + sovPay(uint64(m.TabId))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPay(uint64(m.Status))
	l = len(m.Msg)
	n += 1 + l + sovPay(uint64(l))
	l = m.Data.Size()
	n += 1 + l + sovPay(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigRespData) Size() (n int) {
	var l int
	_ = l
	if len(m.TabConf) > 0 {
		for _, e := range m.TabConf {
			l = e.Size()
			n += 1 + l + sovPay(uint64(l))
		}
	}
	if len(m.Goods) > 0 {
		for _, e := range m.Goods {
			l = e.Size()
			n += 1 + l + sovPay(uint64(l))
		}
	}
	n += 1 + sovPay(uint64(m.TabId))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TabRespData) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPay(uint64(m.Id))
	l = len(m.Name)
	n += 1 + l + sovPay(uint64(l))
	n += 1 + sovPay(uint64(m.Order))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GoodsRespData) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPay(uint64(m.Gid))
	l = len(m.Name)
	n += 1 + l + sovPay(uint64(l))
	l = len(m.Icon)
	n += 1 + l + sovPay(uint64(l))
	n += 1 + sovPay(uint64(m.Order))
	if len(m.Desc) > 0 {
		for _, e := range m.Desc {
			l = e.Size()
			n += 1 + l + sovPay(uint64(l))
		}
	}
	if len(m.Pay) > 0 {
		for _, e := range m.Pay {
			l = e.Size()
			n += 1 + l + sovPay(uint64(l))
		}
	}
	n += 1 + sovPay(uint64(m.LimitNum))
	n += 1 + sovPay(uint64(m.LimitTotal))
	n += 1 + sovPay(uint64(m.SellId))
	n += 1 + sovPay(uint64(m.SellNum))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PayRespData) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPay(uint64(m.PayId))
	n += 5
	n += 5
	l = len(m.Pmode)
	n += 1 + l + sovPay(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DescRespData) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPay(uint64(m.Type))
	l = len(m.FlagIcon)
	n += 1 + l + sovPay(uint64(l))
	l = len(m.Desc)
	n += 1 + l + sovPay(uint64(l))
	if len(m.Detail) > 0 {
		for _, e := range m.Detail {
			l = e.Size()
			n += 1 + l + sovPay(uint64(l))
		}
	}
	n += 1 + sovPay(uint64(m.Dorder))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GiftRespDetail) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPay(uint64(m.GoodsId))
	n += 1 + sovPay(uint64(m.GoodsNum))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderRequest) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPay(uint64(m.Mid))
	n += 1 + sovPay(uint64(m.Pmode))
	n += 5
	n += 1 + sovPay(uint64(m.Number))
	n += 1 + sovPay(uint64(m.Gid))
	n += 1 + sovPay(uint64(m.TabId))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPay(uint64(m.Status))
	l = len(m.Msg)
	n += 1 + l + sovPay(uint64(l))
	l = m.Data.Size()
	n += 1 + l + sovPay(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OrderInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Order)
	n += 1 + l + sovPay(uint64(l))
	n += 1 + sovPay(uint64(m.Gid))
	n += 5
	l = len(m.Pname)
	n += 1 + l + sovPay(uint64(l))
	n += 1 + sovPay(uint64(m.Mid))
	l = len(m.Ext)
	n += 1 + l + sovPay(uint64(l))
	l = len(m.Pid)
	n += 1 + l + sovPay(uint64(l))
	n += 1 + sovPay(uint64(m.Pmode))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Pid)
	n += 1 + l + sovPay(uint64(l))
	l = len(m.Content)
	n += 1 + l + sovPay(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPay(uint64(m.Status))
	l = len(m.Msg)
	n += 1 + l + sovPay(uint64(l))
	l = len(m.Data)
	n += 1 + l + sovPay(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SendMoneyRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Content)
	n += 1 + l + sovPay(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SendMoneyResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPay(uint64(m.Status))
	l = len(m.Msg)
	n += 1 + l + sovPay(uint64(l))
	l = len(m.Data)
	n += 1 + l + sovPay(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPay(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPay(x uint64) (n int) {
	return sovPay(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ConfigRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConfigRequest{`,
		`Mid:` + fmt.Sprintf("%v", this.Mid) + `,`,
		`TabId:` + fmt.Sprintf("%v", this.TabId) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConfigResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConfigResponse{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Msg:` + fmt.Sprintf("%v", this.Msg) + `,`,
		`Data:` + strings.Replace(strings.Replace(this.Data.String(), "ConfigRespData", "ConfigRespData", 1), `&`, ``, 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ConfigRespData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ConfigRespData{`,
		`TabConf:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.TabConf), "TabRespData", "TabRespData", 1), `&`, ``, 1) + `,`,
		`Goods:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Goods), "GoodsRespData", "GoodsRespData", 1), `&`, ``, 1) + `,`,
		`TabId:` + fmt.Sprintf("%v", this.TabId) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TabRespData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TabRespData{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Order:` + fmt.Sprintf("%v", this.Order) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GoodsRespData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GoodsRespData{`,
		`Gid:` + fmt.Sprintf("%v", this.Gid) + `,`,
		`Name:` + fmt.Sprintf("%v", this.Name) + `,`,
		`Icon:` + fmt.Sprintf("%v", this.Icon) + `,`,
		`Order:` + fmt.Sprintf("%v", this.Order) + `,`,
		`Desc:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Desc), "DescRespData", "DescRespData", 1), `&`, ``, 1) + `,`,
		`Pay:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Pay), "PayRespData", "PayRespData", 1), `&`, ``, 1) + `,`,
		`LimitNum:` + fmt.Sprintf("%v", this.LimitNum) + `,`,
		`LimitTotal:` + fmt.Sprintf("%v", this.LimitTotal) + `,`,
		`SellId:` + fmt.Sprintf("%v", this.SellId) + `,`,
		`SellNum:` + fmt.Sprintf("%v", this.SellNum) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PayRespData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PayRespData{`,
		`PayId:` + fmt.Sprintf("%v", this.PayId) + `,`,
		`OldPayNum:` + fmt.Sprintf("%v", this.OldPayNum) + `,`,
		`PayNum:` + fmt.Sprintf("%v", this.PayNum) + `,`,
		`Pmode:` + fmt.Sprintf("%v", this.Pmode) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DescRespData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DescRespData{`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`FlagIcon:` + fmt.Sprintf("%v", this.FlagIcon) + `,`,
		`Desc:` + fmt.Sprintf("%v", this.Desc) + `,`,
		`Detail:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Detail), "GiftRespDetail", "GiftRespDetail", 1), `&`, ``, 1) + `,`,
		`Dorder:` + fmt.Sprintf("%v", this.Dorder) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GiftRespDetail) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GiftRespDetail{`,
		`GoodsId:` + fmt.Sprintf("%v", this.GoodsId) + `,`,
		`GoodsNum:` + fmt.Sprintf("%v", this.GoodsNum) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderRequest{`,
		`Mid:` + fmt.Sprintf("%v", this.Mid) + `,`,
		`Pmode:` + fmt.Sprintf("%v", this.Pmode) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`Number:` + fmt.Sprintf("%v", this.Number) + `,`,
		`Gid:` + fmt.Sprintf("%v", this.Gid) + `,`,
		`TabId:` + fmt.Sprintf("%v", this.TabId) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderResponse{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Msg:` + fmt.Sprintf("%v", this.Msg) + `,`,
		`Data:` + strings.Replace(strings.Replace(this.Data.String(), "OrderInfo", "OrderInfo", 1), `&`, ``, 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderInfo{`,
		`Order:` + fmt.Sprintf("%v", this.Order) + `,`,
		`Gid:` + fmt.Sprintf("%v", this.Gid) + `,`,
		`Pamount:` + fmt.Sprintf("%v", this.Pamount) + `,`,
		`Pname:` + fmt.Sprintf("%v", this.Pname) + `,`,
		`Mid:` + fmt.Sprintf("%v", this.Mid) + `,`,
		`Ext:` + fmt.Sprintf("%v", this.Ext) + `,`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`Pmode:` + fmt.Sprintf("%v", this.Pmode) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReportRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReportRequest{`,
		`Pid:` + fmt.Sprintf("%v", this.Pid) + `,`,
		`Content:` + fmt.Sprintf("%v", this.Content) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReportResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReportResponse{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Msg:` + fmt.Sprintf("%v", this.Msg) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendMoneyRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendMoneyRequest{`,
		`Content:` + fmt.Sprintf("%v", this.Content) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SendMoneyResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SendMoneyResponse{`,
		`Status:` + fmt.Sprintf("%v", this.Status) + `,`,
		`Msg:` + fmt.Sprintf("%v", this.Msg) + `,`,
		`Data:` + fmt.Sprintf("%v", this.Data) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringPay(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ConfigRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabId", wireType)
			}
			m.TabId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipPay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("mid")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("tabId")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("status")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("msg")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigRespData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigRespData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigRespData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabConf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TabConf = append(m.TabConf, TabRespData{})
			if err := m.TabConf[len(m.TabConf)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Goods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Goods = append(m.Goods, GoodsRespData{})
			if err := m.Goods[len(m.Goods)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabId", wireType)
			}
			m.TabId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TabRespData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TabRespData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TabRespData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoodsRespData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoodsRespData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoodsRespData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			m.Order = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Order |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = append(m.Desc, DescRespData{})
			if err := m.Desc[len(m.Desc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pay = append(m.Pay, PayRespData{})
			if err := m.Pay[len(m.Pay)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitNum", wireType)
			}
			m.LimitNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitTotal", wireType)
			}
			m.LimitTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitTotal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellId", wireType)
			}
			m.SellId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellNum", wireType)
			}
			m.SellNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayRespData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayRespData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayRespData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayId", wireType)
			}
			m.PayId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PayId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldPayNum", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.OldPayNum = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayNum", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PayNum = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pmode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pmode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescRespData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescRespData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescRespData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlagIcon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlagIcon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Desc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = append(m.Detail, GiftRespDetail{})
			if err := m.Detail[len(m.Detail)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dorder", wireType)
			}
			m.Dorder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dorder |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GiftRespDetail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GiftRespDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GiftRespDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsId", wireType)
			}
			m.GoodsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoodsId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsNum", wireType)
			}
			m.GoodsNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoodsNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pmode", wireType)
			}
			m.Pmode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pmode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Price = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TabId", wireType)
			}
			m.TabId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TabId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("status")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("msg")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Order = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pamount", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Pamount = float32(math.Float32frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			m.Mid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pmode", wireType)
			}
			m.Pmode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pmode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipPay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("pid")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("content")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipPay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("status")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("msg")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return proto.NewRequiredNotSetError("data")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMoneyRequest) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendMoneyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendMoneyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipPay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("content")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SendMoneyResponse) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPay
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendMoneyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendMoneyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPay
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPay
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipPay(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPay
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return proto.NewRequiredNotSetError("status")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return proto.NewRequiredNotSetError("msg")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return proto.NewRequiredNotSetError("data")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPay(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPay
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPay
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPay
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPay
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPay
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPay(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPay = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPay   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("pay/pay.proto", fileDescriptorPay) }

var fileDescriptorPay = []byte{
	// 827 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x55, 0x3d, 0x6f, 0xe3, 0x46,
	0x10, 0xf5, 0x52, 0x5f, 0xd6, 0xc8, 0x32, 0x9c, 0x8d, 0x63, 0x10, 0x46, 0xc0, 0x08, 0x44, 0x0a,
	0xc1, 0x48, 0xa4, 0x40, 0xc9, 0x2f, 0xb0, 0x0d, 0x18, 0x2a, 0x92, 0x18, 0x8a, 0x9b, 0x74, 0x59,
	0x91, 0x2b, 0x86, 0x80, 0xc8, 0xa5, 0xc5, 0x55, 0x62, 0x76, 0xe9, 0xd2, 0xe7, 0x57, 0xa4, 0x4c,
	0x97, 0x94, 0x29, 0x5d, 0xa6, 0x74, 0x95, 0xb3, 0xf4, 0x0b, 0xae, 0xbc, 0xf2, 0xb0, 0xc3, 0x0f,
	0xed, 0x52, 0x87, 0x6b, 0x8c, 0xeb, 0xa8, 0x37, 0xb3, 0x6f, 0x66, 0xdf, 0xdb, 0x19, 0x41, 0x3f,
	0x61, 0xd9, 0x38, 0x61, 0xd9, 0x28, 0x59, 0x09, 0x29, 0x68, 0x2b, 0x09, 0x6e, 0x59, 0x76, 0xfe,
	0xcd, 0x2f, 0x3c, 0xf6, 0xc5, 0x6a, 0x1c, 0x84, 0xf2, 0xe7, 0xf5, 0x7c, 0xe4, 0x89, 0x68, 0x1c,
	0x88, 0x40, 0x8c, 0x31, 0x69, 0xbe, 0x5e, 0xe0, 0x2f, 0xfc, 0x81, 0x5f, 0xf9, 0x61, 0xf7, 0x0a,
	0xfa, 0x57, 0x22, 0x5e, 0x84, 0xc1, 0x8c, 0xdf, 0xaf, 0x79, 0x2a, 0xe9, 0x19, 0x34, 0xa2, 0xd0,
	0xb7, 0xc9, 0xc0, 0x1a, 0x36, 0x2e, 0x9b, 0x8f, 0xff, 0x7f, 0x76, 0x30, 0x53, 0x00, 0x3d, 0x87,
	0x96, 0x64, 0xf3, 0xa9, 0x6f, 0x5b, 0x03, 0x6b, 0xd8, 0x2a, 0x22, 0x39, 0xe4, 0xfe, 0x0a, 0xc7,
	0x25, 0x49, 0x9a, 0x88, 0x38, 0xe5, 0xf4, 0x53, 0x68, 0xa7, 0x92, 0xc9, 0x75, 0x8a, 0x44, 0x65,
	0x7a, 0x81, 0x61, 0x8d, 0x34, 0x40, 0xa6, 0x6e, 0x55, 0x23, 0x0d, 0xe8, 0x18, 0x9a, 0x3e, 0x93,
	0xcc, 0x6e, 0x0c, 0xc8, 0xb0, 0x37, 0xf9, 0x64, 0x84, 0x17, 0x1b, 0xed, 0xa8, 0xaf, 0x99, 0x64,
	0x45, 0x3e, 0x26, 0xba, 0x7f, 0x10, 0xbd, 0xb2, 0x0a, 0xd3, 0x09, 0x74, 0x24, 0x9b, 0x2b, 0xd0,
	0x26, 0x83, 0xc6, 0xb0, 0x37, 0xa1, 0x05, 0xcd, 0x1d, 0x9b, 0xd7, 0x38, 0xca, 0x44, 0xfa, 0x15,
	0xb4, 0x02, 0x21, 0xfc, 0xd4, 0xb6, 0xf0, 0xc4, 0x69, 0x71, 0xe2, 0x46, 0x61, 0xb5, 0x33, 0x79,
	0xe2, 0x4e, 0x0d, 0xd5, 0x6a, 0x4d, 0x8d, 0x1f, 0xa1, 0xa7, 0xd5, 0xa2, 0xa7, 0x60, 0xa1, 0x9e,
	0xbb, 0x3c, 0x2b, 0xf4, 0xa9, 0x0d, 0xcd, 0x98, 0x45, 0xdc, 0xb6, 0x06, 0xa4, 0xd2, 0x00, 0x11,
	0x45, 0x2d, 0x56, 0x3e, 0x5f, 0x99, 0xd4, 0x08, 0xb9, 0x4f, 0x16, 0xf4, 0x8d, 0xae, 0x94, 0x94,
	0x41, 0x8d, 0x5e, 0x01, 0xef, 0xe1, 0xb7, 0xa1, 0x19, 0x7a, 0x22, 0x46, 0xfa, 0x2a, 0xa2, 0x90,
	0x5d, 0xe5, 0xe6, 0x5e, 0x65, 0xfa, 0x25, 0x34, 0x7d, 0x9e, 0x7a, 0x76, 0x0b, 0x15, 0xfa, 0xb8,
	0x50, 0xe8, 0x9a, 0xa7, 0xde, 0x9e, 0x31, 0x3c, 0xf5, 0xe8, 0x05, 0x34, 0x12, 0x96, 0xd9, 0x6d,
	0xc3, 0x81, 0x5b, 0x96, 0xd5, 0x92, 0x55, 0x12, 0x1d, 0xc0, 0xe1, 0x32, 0x8c, 0x42, 0xf9, 0xdd,
	0x3a, 0xb2, 0x3b, 0x5a, 0xe5, 0x0a, 0xa5, 0x9f, 0x03, 0xe0, 0xf7, 0x9d, 0x90, 0x6c, 0x69, 0x1f,
	0x6a, 0x39, 0x1a, 0x8e, 0x6f, 0x8e, 0x2f, 0x97, 0x53, 0xdf, 0xee, 0x6a, 0x19, 0x05, 0x46, 0x1d,
	0xe8, 0xa8, 0x2f, 0x55, 0x04, 0xb4, 0x70, 0x09, 0xba, 0xbf, 0x13, 0xe8, 0x69, 0x0d, 0x2a, 0x31,
	0x12, 0x96, 0x4d, 0x4d, 0x69, 0x73, 0x88, 0xba, 0xd0, 0x15, 0x4b, 0xff, 0x96, 0x65, 0x8a, 0x4d,
	0x29, 0x6c, 0x15, 0xf1, 0x1d, 0xac, 0xba, 0x49, 0xf2, 0x84, 0x86, 0x96, 0x50, 0x60, 0xc8, 0x1e,
	0x09, 0x9f, 0xa3, 0xd4, 0xdd, 0x8a, 0x5d, 0x41, 0xee, 0xdf, 0x04, 0x8e, 0x74, 0x61, 0x95, 0x63,
	0x32, 0x4b, 0xb8, 0xd1, 0x09, 0x22, 0x4a, 0xba, 0xc5, 0x92, 0x05, 0x53, 0xe5, 0xa7, 0xee, 0x74,
	0x85, 0xaa, 0xb3, 0xe8, 0x9b, 0xe1, 0x36, 0x5a, 0xf4, 0x35, 0xb4, 0x7d, 0x2e, 0x59, 0xb8, 0xb4,
	0x9b, 0xe8, 0x52, 0x39, 0x6e, 0x37, 0xe1, 0x42, 0x62, 0x69, 0x0c, 0x96, 0x7d, 0xe7, 0xa9, 0xea,
	0x56, 0x7e, 0xfe, 0x46, 0x5a, 0xba, 0xc6, 0x39, 0xe6, 0xce, 0xe0, 0xd8, 0x3c, 0xad, 0x54, 0xc7,
	0x81, 0xa9, 0xe9, 0x58, 0x82, 0xea, 0x02, 0xf8, 0x59, 0x0a, 0x59, 0x79, 0x5f, 0xa2, 0xee, 0x5f,
	0x04, 0x8e, 0xbe, 0x57, 0xec, 0x7b, 0x0b, 0x8a, 0xec, 0x2d, 0xa8, 0x5c, 0x52, 0xcb, 0x30, 0x4c,
	0x41, 0x18, 0x5b, 0x85, 0x1e, 0x37, 0xbc, 0xc8, 0x21, 0x75, 0xa5, 0x78, 0x1d, 0xcd, 0x6b, 0xcf,
	0xbe, 0xc0, 0xca, 0xf9, 0x6a, 0xd5, 0xe7, 0xab, 0x5a, 0x00, 0xed, 0xfd, 0x05, 0x70, 0x0f, 0xfd,
	0xa2, 0xe3, 0x17, 0x6d, 0xc3, 0x0b, 0x63, 0x1b, 0x9e, 0x14, 0xf6, 0x20, 0xf3, 0x34, 0x5e, 0x08,
	0x63, 0x11, 0xbe, 0x22, 0xd0, 0xad, 0x22, 0xbb, 0x41, 0x26, 0xfa, 0xeb, 0xca, 0x07, 0xb9, 0xb8,
	0x90, 0x55, 0xbf, 0x90, 0x03, 0x9d, 0x84, 0x45, 0x62, 0x1d, 0x4b, 0x43, 0xa4, 0x12, 0x44, 0x09,
	0x71, 0xa3, 0x98, 0x2f, 0x16, 0x57, 0x4a, 0x61, 0x89, 0x21, 0x92, 0xb2, 0xe4, 0x0c, 0x1a, 0xfc,
	0x41, 0xa2, 0x44, 0xd5, 0xcd, 0xf8, 0x03, 0x5a, 0x98, 0x84, 0x3e, 0x0e, 0x7b, 0x85, 0x27, 0xba,
	0x85, 0x87, 0x7b, 0x16, 0xba, 0x37, 0xd0, 0x9f, 0xf1, 0x44, 0xac, 0xa4, 0xf6, 0x0e, 0x92, 0xe2,
	0x8f, 0xca, 0x20, 0x71, 0xa0, 0xe3, 0x89, 0x58, 0xf2, 0x58, 0x1a, 0x92, 0x96, 0xa0, 0xfb, 0x13,
	0x1c, 0x97, 0x44, 0x2f, 0xb2, 0xc7, 0xae, 0xec, 0xb1, 0xb4, 0xc9, 0x52, 0x66, 0x4c, 0xe0, 0xe4,
	0x07, 0x1e, 0xfb, 0xdf, 0x8a, 0x98, 0x67, 0x65, 0xb7, 0x5a, 0x57, 0xe4, 0x5d, 0x5d, 0x79, 0xf0,
	0x91, 0x76, 0xe6, 0xc3, 0x34, 0x76, 0xf9, 0xc5, 0xd3, 0xc6, 0x39, 0x78, 0xde, 0x38, 0xe4, 0xf5,
	0xc6, 0x21, 0x6f, 0x36, 0x0e, 0xf9, 0x6d, 0xeb, 0x90, 0x3f, 0xb7, 0x0e, 0xf9, 0x67, 0xeb, 0x90,
	0x7f, 0xb7, 0x0e, 0x79, 0xdc, 0x3a, 0xe4, 0xbf, 0xad, 0x43, 0x9e, 0xb7, 0x0e, 0x79, 0x1b, 0x00,
	0x00, 0xff, 0xff, 0x9e, 0xdf, 0xc3, 0x22, 0x67, 0x08, 0x00, 0x00,
}
